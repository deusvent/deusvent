#pragma clang diagnostic ignored "-Wpessimizing-move"
/* This file was generated by uniffi-bindgen-cpp. */
#include <string>

#include "logic.hpp"

namespace logic {
namespace uniffi {
template <class> inline constexpr bool always_false_v = false;

namespace {
void ensure_initialized() {
    auto bindings_contract_version = 24;
    auto scaffolding_contract_version = ffi_logic_uniffi_contract_version();

    if (bindings_contract_version != scaffolding_contract_version) {
        throw std::runtime_error(
            "UniFFI contract version mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_decay_message_tag() != 47840) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_servererror_message_tag() != 13551) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_serverstatus_message_tag() != 55415) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_generate_new_keys() != 64904) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_parse_request_id() != 49778) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_serialize_me() != 8171) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decay_debug_string() != 57020) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decay_length() != 56226) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decay_started_at() != 5715) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decayquery_debug_string() != 61579) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decayquery_serialize() != 36994) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_duration_whole_days() != 58703) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_duration_whole_hours() != 60524) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_duration_whole_minutes() != 14664) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_encryptedstring_decrypt() != 14315) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_identity_debug_string() != 60222) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_identity_serialize() != 6829) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_ping_debug_string() != 20808) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_ping_serialize() != 14360) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_ping2_serialize() != 27235) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_privatekey_serialize() != 39381) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_publickey_as_string() != 5145) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_publickey_serialize() != 18621) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serializable_serialize() != 65412) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererror_debug_string() != 7814) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererror_error_code() != 13159) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererror_error_context() != 17416) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererror_error_description() != 52686) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererror_message_tag() != 6999) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererror_recoverable() != 4637) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererror_request_id() != 43868) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatus_debug_string() != 4100) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatus_status() != 14790) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatus_timestamp() != 12456) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servertimestamp_as_string() != 29463) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_syncedtimestamp_adjust() != 41584) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_syncedtimestamp_now() != 943) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_timestamp_as_string() != 3604) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_timestamp_diff() != 48627) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_decay_deserialize() != 16798) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_decayquery_new() != 39381) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_duration_from_milliseconds() != 62484) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_encryptedstring_new() != 41058) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_ping_new() != 18958) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_ping2_new() != 24007) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_privatekey_deserialize() != 51694) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_publickey_deserialize() != 26224) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_servererror_deserialize() != 44940) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_serverstatus_deserialize() != 59390) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_servertimestamp_from_milliseconds() != 5946) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_syncedtimestamp_new() != 19626) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_timestamp_from_milliseconds() != 19208) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_timestamp_now() != 17293) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
}

// Note: we need this indirection here and can't inline this code in the rust_call function
// as it's a templated function
void initialize() {
    static std::once_flag init_flag;
    std::call_once(init_flag, ensure_initialized);
}
} // namespace

template <typename F> void check_rust_call(const RustCallStatus &status, F error_cb) {
    switch (status.code) {
    case 0:
        return;

    case 1:
        if constexpr (!std::is_null_pointer_v<F>) {
            error_cb(status.error_buf)->throw_underlying();
        }
        break;

    case 2:
        if (status.error_buf.len > 0) {
            throw std::runtime_error(FfiConverterString::lift(status.error_buf));
        }

        throw std::runtime_error("A Rust panic has occurred");
    }

    throw std::runtime_error("Unexpected Rust call status");
}

template <typename F,
          typename EF,
          typename... Args,
          typename R = std::invoke_result_t<F, Args..., RustCallStatus *>>
R rust_call(F f, EF error_cb, Args... args) {
    initialize();

    RustCallStatus status = {0};

    if constexpr (std::is_void_v<R>) {
        f(args..., &status);
        check_rust_call(status, error_cb);
    } else {
        auto ret = f(args..., &status);
        check_rust_call(status, error_cb);

        return ret;
    }
}

RustBuffer rustbuffer_alloc(int32_t len) {
    RustCallStatus status = {0};
    auto buffer = ffi_logic_rustbuffer_alloc(len, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

RustBuffer rustbuffer_from_bytes(const ForeignBytes &bytes) {
    RustCallStatus status = {0};
    auto buffer = ffi_logic_rustbuffer_from_bytes(bytes, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = {0};

    ffi_logic_rustbuffer_free(std::move(buf), &status);
    check_rust_call(status, nullptr);
}

uint8_t FfiConverterUInt8::lift(uint8_t val) {
    return val;
}

uint8_t FfiConverterUInt8::lower(uint8_t val) {
    return val;
}

uint8_t FfiConverterUInt8::read(RustStream &stream) {
    uint8_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt8::write(RustStream &stream, uint8_t val) {
    stream << val;
}

int32_t FfiConverterUInt8::allocation_size(uint8_t) {
    return static_cast<int32_t>(sizeof(uint8_t));
}
uint16_t FfiConverterUInt16::lift(uint16_t val) {
    return val;
}

uint16_t FfiConverterUInt16::lower(uint16_t val) {
    return val;
}

uint16_t FfiConverterUInt16::read(RustStream &stream) {
    uint16_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt16::write(RustStream &stream, uint16_t val) {
    stream << val;
}

int32_t FfiConverterUInt16::allocation_size(uint16_t) {
    return static_cast<int32_t>(sizeof(uint16_t));
}
uint64_t FfiConverterUInt64::lift(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::lower(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::read(RustStream &stream) {
    uint64_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt64::write(RustStream &stream, uint64_t val) {
    stream << val;
}

int32_t FfiConverterUInt64::allocation_size(uint64_t) {
    return static_cast<int32_t>(sizeof(uint64_t));
}

bool FfiConverterBool::lift(uint8_t val) {
    return !!val;
}

uint8_t FfiConverterBool::lower(bool val) {
    return val;
}

bool FfiConverterBool::read(RustStream &stream) {
    uint8_t val;
    stream >> val;

    return val;
}

void FfiConverterBool::write(RustStream &stream, bool val) {
    stream << val;
}

int32_t FfiConverterBool::allocation_size(bool) {
    return 1;
}
std::string FfiConverterString::lift(RustBuffer buf) {
    auto string = std::string(reinterpret_cast<char *>(buf.data), buf.len);

    rustbuffer_free(buf);

    return string;
}

RustBuffer FfiConverterString::lower(const std::string &val) {
    auto len = static_cast<int32_t>(val.length());
    auto bytes = ForeignBytes{len, reinterpret_cast<uint8_t *>(const_cast<char *>(val.data()))};

    return rustbuffer_from_bytes(bytes);
}

std::string FfiConverterString::read(RustStream &stream) {
    int32_t len;
    std::string string;

    stream >> len;

    string.resize(len);
    stream.read(string.data(), len);

    return string;
}

void FfiConverterString::write(RustStream &stream, const std::string &val) {
    stream << static_cast<int32_t>(val.length());
    stream.write(val.data(), val.length());
}

int32_t FfiConverterString::allocation_size(const std::string &val) {
    return static_cast<int32_t>(sizeof(int32_t) + val.length());
}

std::vector<uint8_t> FfiConverterBytes::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterBytes::lower(const std::vector<uint8_t> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<uint8_t> FfiConverterBytes::read(RustStream &stream) {
    std::vector<uint8_t> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        uint8_t elem;
        stream >> elem;
        ret.push_back(elem);
    }

    return ret;
}

void FfiConverterBytes::write(RustStream &stream, const std::vector<uint8_t> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        stream << elem;
    }
}

int32_t FfiConverterBytes::allocation_size(const std::vector<uint8_t> &val) {
    return static_cast<int32_t>(sizeof(int32_t) + sizeof(uint8_t) * val.size());
}
} // namespace uniffi

Decay::Decay(void *ptr) : instance(ptr) {
}

std::shared_ptr<Decay> Decay::deserialize(const std::string &data) {
    return std::shared_ptr<Decay>(
        new Decay(uniffi::rust_call(uniffi_logic_fn_constructor_decay_deserialize,
                                    uniffi::FfiConverterTypeSerializationError::lift,
                                    uniffi::FfiConverterString::lower(data))));
}

std::string Decay::debug_string() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_decay_debug_string, nullptr, this->instance));
}
std::shared_ptr<Duration> Decay::length() {
    return uniffi::FfiConverterDuration::lift(
        uniffi::rust_call(uniffi_logic_fn_method_decay_length, nullptr, this->instance));
}
std::shared_ptr<ServerTimestamp> Decay::started_at() {
    return uniffi::FfiConverterServerTimestamp::lift(
        uniffi::rust_call(uniffi_logic_fn_method_decay_started_at, nullptr, this->instance));
}

Decay::~Decay() {
    uniffi::rust_call(uniffi_logic_fn_free_decay, nullptr, this->instance);
}

DecayQuery::DecayQuery(void *ptr) : instance(ptr) {
}

std::shared_ptr<DecayQuery> DecayQuery::init() {
    return std::shared_ptr<DecayQuery>(
        new DecayQuery(uniffi::rust_call(uniffi_logic_fn_constructor_decayquery_new, nullptr)));
}

std::string DecayQuery::debug_string() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_decayquery_debug_string, nullptr, this->instance));
}
std::string DecayQuery::serialize(uint8_t request_id, const Keys &keys) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_decayquery_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id),
                          uniffi::FfiConverterTypeKeys::lower(keys)));
}

DecayQuery::~DecayQuery() {
    uniffi::rust_call(uniffi_logic_fn_free_decayquery, nullptr, this->instance);
}

Duration::Duration(void *ptr) : instance(ptr) {
}

std::shared_ptr<Duration> Duration::from_milliseconds(uint64_t milliseconds) {
    return std::shared_ptr<Duration>(
        new Duration(uniffi::rust_call(uniffi_logic_fn_constructor_duration_from_milliseconds,
                                       nullptr,
                                       uniffi::FfiConverterUInt64::lower(milliseconds))));
}

uint64_t Duration::whole_days() {
    return uniffi::FfiConverterUInt64::lift(
        uniffi::rust_call(uniffi_logic_fn_method_duration_whole_days, nullptr, this->instance));
}
uint64_t Duration::whole_hours() {
    return uniffi::FfiConverterUInt64::lift(
        uniffi::rust_call(uniffi_logic_fn_method_duration_whole_hours, nullptr, this->instance));
}
uint64_t Duration::whole_minutes() {
    return uniffi::FfiConverterUInt64::lift(
        uniffi::rust_call(uniffi_logic_fn_method_duration_whole_minutes, nullptr, this->instance));
}

Duration::~Duration() {
    uniffi::rust_call(uniffi_logic_fn_free_duration, nullptr, this->instance);
}

EncryptedString::EncryptedString(void *ptr) : instance(ptr) {
}

std::shared_ptr<EncryptedString>
EncryptedString::init(const std::string &plaintext,
                      const std::shared_ptr<PrivateKey> &private_key) {
    return std::shared_ptr<EncryptedString>(
        new EncryptedString(uniffi::rust_call(uniffi_logic_fn_constructor_encryptedstring_new,
                                              nullptr,
                                              uniffi::FfiConverterString::lower(plaintext),
                                              uniffi::FfiConverterPrivateKey::lower(private_key))));
}

std::string EncryptedString::decrypt(const std::shared_ptr<PrivateKey> &private_key) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_encryptedstring_decrypt,
                          uniffi::FfiConverterTypeEncryptionError::lift,
                          this->instance,
                          uniffi::FfiConverterPrivateKey::lower(private_key)));
}

EncryptedString::~EncryptedString() {
    uniffi::rust_call(uniffi_logic_fn_free_encryptedstring, nullptr, this->instance);
}

Identity::Identity(void *ptr) : instance(ptr) {
}

std::string Identity::debug_string() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_identity_debug_string, nullptr, this->instance));
}
std::string Identity::serialize(uint8_t request_id, const Keys &keys) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_identity_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id),
                          uniffi::FfiConverterTypeKeys::lower(keys)));
}

Identity::~Identity() {
    uniffi::rust_call(uniffi_logic_fn_free_identity, nullptr, this->instance);
}

Ping::Ping(void *ptr) : instance(ptr) {
}

std::shared_ptr<Ping> Ping::init() {
    return std::shared_ptr<Ping>(
        new Ping(uniffi::rust_call(uniffi_logic_fn_constructor_ping_new, nullptr)));
}

std::string Ping::debug_string() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_ping_debug_string, nullptr, this->instance));
}
std::string Ping::serialize(uint8_t request_id) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_ping_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id)));
}

Ping::~Ping() {
    uniffi::rust_call(uniffi_logic_fn_free_ping, nullptr, this->instance);
}

Ping2::Ping2(void *ptr) : instance(ptr) {
}

std::shared_ptr<Ping2> Ping2::init() {
    return std::shared_ptr<Ping2>(
        new Ping2(uniffi::rust_call(uniffi_logic_fn_constructor_ping2_new, nullptr)));
}

std::string Ping2::serialize(uint8_t request_id) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_ping2_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id)));
}

Ping2::~Ping2() {
    uniffi::rust_call(uniffi_logic_fn_free_ping2, nullptr, this->instance);
}

PlayerId::PlayerId(void *ptr) : instance(ptr) {
}

PlayerId::~PlayerId() {
    uniffi::rust_call(uniffi_logic_fn_free_playerid, nullptr, this->instance);
}

PrivateKey::PrivateKey(void *ptr) : instance(ptr) {
}

std::shared_ptr<PrivateKey> PrivateKey::deserialize(const std::vector<uint8_t> &data) {
    return std::shared_ptr<PrivateKey>(
        new PrivateKey(uniffi::rust_call(uniffi_logic_fn_constructor_privatekey_deserialize,
                                         uniffi::FfiConverterTypeSerializationError::lift,
                                         uniffi::FfiConverterBytes::lower(data))));
}

std::vector<uint8_t> PrivateKey::serialize() {
    return uniffi::FfiConverterBytes::lift(
        uniffi::rust_call(uniffi_logic_fn_method_privatekey_serialize, nullptr, this->instance));
}

PrivateKey::~PrivateKey() {
    uniffi::rust_call(uniffi_logic_fn_free_privatekey, nullptr, this->instance);
}

PublicKey::PublicKey(void *ptr) : instance(ptr) {
}

std::shared_ptr<PublicKey> PublicKey::deserialize(const std::vector<uint8_t> &data) {
    return std::shared_ptr<PublicKey>(
        new PublicKey(uniffi::rust_call(uniffi_logic_fn_constructor_publickey_deserialize,
                                        uniffi::FfiConverterTypeSerializationError::lift,
                                        uniffi::FfiConverterBytes::lower(data))));
}

std::string PublicKey::as_string() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_publickey_as_string, nullptr, this->instance));
}
std::vector<uint8_t> PublicKey::serialize() {
    return uniffi::FfiConverterBytes::lift(
        uniffi::rust_call(uniffi_logic_fn_method_publickey_serialize, nullptr, this->instance));
}

PublicKey::~PublicKey() {
    uniffi::rust_call(uniffi_logic_fn_free_publickey, nullptr, this->instance);
}

Serializable::Serializable(void *ptr) : instance(ptr) {
}

std::string Serializable::serialize(uint8_t request_id) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_serializable_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id)));
}

Serializable::~Serializable() {
    uniffi::rust_call(uniffi_logic_fn_free_serializable, nullptr, this->instance);
}

ServerError::ServerError(void *ptr) : instance(ptr) {
}

std::shared_ptr<ServerError> ServerError::deserialize(const std::string &data) {
    return std::shared_ptr<ServerError>(
        new ServerError(uniffi::rust_call(uniffi_logic_fn_constructor_servererror_deserialize,
                                          uniffi::FfiConverterTypeSerializationError::lift,
                                          uniffi::FfiConverterString::lower(data))));
}

std::string ServerError::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_servererror_debug_string, nullptr, this->instance));
}
ErrorCode ServerError::error_code() {
    return uniffi::FfiConverterTypeErrorCode::lift(
        uniffi::rust_call(uniffi_logic_fn_method_servererror_error_code, nullptr, this->instance));
}
std::optional<std::string> ServerError::error_context() {
    return uniffi::FfiConverterOptionalString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_servererror_error_context, nullptr, this->instance));
}
std::string ServerError::error_description() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_servererror_error_description, nullptr, this->instance));
}
uint16_t ServerError::message_tag() {
    return uniffi::FfiConverterUInt16::lift(
        uniffi::rust_call(uniffi_logic_fn_method_servererror_message_tag, nullptr, this->instance));
}
bool ServerError::recoverable() {
    return uniffi::FfiConverterBool::lift(
        uniffi::rust_call(uniffi_logic_fn_method_servererror_recoverable, nullptr, this->instance));
}
uint8_t ServerError::request_id() {
    return uniffi::FfiConverterUInt8::lift(
        uniffi::rust_call(uniffi_logic_fn_method_servererror_request_id, nullptr, this->instance));
}

ServerError::~ServerError() {
    uniffi::rust_call(uniffi_logic_fn_free_servererror, nullptr, this->instance);
}

ServerStatus::ServerStatus(void *ptr) : instance(ptr) {
}

std::shared_ptr<ServerStatus> ServerStatus::deserialize(const std::string &data) {
    return std::shared_ptr<ServerStatus>(
        new ServerStatus(uniffi::rust_call(uniffi_logic_fn_constructor_serverstatus_deserialize,
                                           uniffi::FfiConverterTypeSerializationError::lift,
                                           uniffi::FfiConverterString::lower(data))));
}

std::string ServerStatus::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_serverstatus_debug_string, nullptr, this->instance));
}
Status ServerStatus::status() {
    return uniffi::FfiConverterTypeStatus::lift(
        uniffi::rust_call(uniffi_logic_fn_method_serverstatus_status, nullptr, this->instance));
}
std::shared_ptr<ServerTimestamp> ServerStatus::timestamp() {
    return uniffi::FfiConverterServerTimestamp::lift(
        uniffi::rust_call(uniffi_logic_fn_method_serverstatus_timestamp, nullptr, this->instance));
}

ServerStatus::~ServerStatus() {
    uniffi::rust_call(uniffi_logic_fn_free_serverstatus, nullptr, this->instance);
}

ServerTimestamp::ServerTimestamp(void *ptr) : instance(ptr) {
}

std::shared_ptr<ServerTimestamp> ServerTimestamp::from_milliseconds(uint64_t milliseconds) {
    return std::shared_ptr<ServerTimestamp>(new ServerTimestamp(
        uniffi::rust_call(uniffi_logic_fn_constructor_servertimestamp_from_milliseconds,
                          nullptr,
                          uniffi::FfiConverterUInt64::lower(milliseconds))));
}

std::string ServerTimestamp::as_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_servertimestamp_as_string, nullptr, this->instance));
}

ServerTimestamp::~ServerTimestamp() {
    uniffi::rust_call(uniffi_logic_fn_free_servertimestamp, nullptr, this->instance);
}

SyncedTimestamp::SyncedTimestamp(void *ptr) : instance(ptr) {
}

std::shared_ptr<SyncedTimestamp> SyncedTimestamp::init() {
    return std::shared_ptr<SyncedTimestamp>(new SyncedTimestamp(
        uniffi::rust_call(uniffi_logic_fn_constructor_syncedtimestamp_new, nullptr)));
}

void SyncedTimestamp::adjust(const std::shared_ptr<ServerTimestamp> &server_time,
                             const std::shared_ptr<Timestamp> &sent_at,
                             const std::shared_ptr<Timestamp> &received_at) {
    uniffi::rust_call(uniffi_logic_fn_method_syncedtimestamp_adjust,
                      nullptr,
                      this->instance,
                      uniffi::FfiConverterServerTimestamp::lower(server_time),
                      uniffi::FfiConverterTimestamp::lower(sent_at),
                      uniffi::FfiConverterTimestamp::lower(received_at));
}
std::shared_ptr<Timestamp> SyncedTimestamp::now() {
    return uniffi::FfiConverterTimestamp::lift(
        uniffi::rust_call(uniffi_logic_fn_method_syncedtimestamp_now, nullptr, this->instance));
}

SyncedTimestamp::~SyncedTimestamp() {
    uniffi::rust_call(uniffi_logic_fn_free_syncedtimestamp, nullptr, this->instance);
}

Timestamp::Timestamp(void *ptr) : instance(ptr) {
}

std::shared_ptr<Timestamp> Timestamp::from_milliseconds(uint64_t milliseconds) {
    return std::shared_ptr<Timestamp>(
        new Timestamp(uniffi::rust_call(uniffi_logic_fn_constructor_timestamp_from_milliseconds,
                                        nullptr,
                                        uniffi::FfiConverterUInt64::lower(milliseconds))));
}

std::shared_ptr<Timestamp> Timestamp::now() {
    return std::shared_ptr<Timestamp>(
        new Timestamp(uniffi::rust_call(uniffi_logic_fn_constructor_timestamp_now, nullptr)));
}

std::string Timestamp::as_string() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_timestamp_as_string, nullptr, this->instance));
}
std::shared_ptr<Duration> Timestamp::diff(const std::shared_ptr<Timestamp> &other) {
    return uniffi::FfiConverterDuration::lift(
        uniffi::rust_call(uniffi_logic_fn_method_timestamp_diff,
                          nullptr,
                          this->instance,
                          uniffi::FfiConverterTimestamp::lower(other)));
}

Timestamp::~Timestamp() {
    uniffi::rust_call(uniffi_logic_fn_free_timestamp, nullptr, this->instance);
}

namespace uniffi {

std::shared_ptr<Decay> FfiConverterDecay::lift(void *ptr) {
    return std::shared_ptr<Decay>(new Decay(ptr));
}

void *FfiConverterDecay::lower(const std::shared_ptr<Decay> &obj) {
    return obj->instance;
}

std::shared_ptr<Decay> FfiConverterDecay::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Decay>(new Decay(reinterpret_cast<void *>(ptr)));
}

void FfiConverterDecay::write(RustStream &stream, const std::shared_ptr<Decay> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterDecay::allocation_size(const std::shared_ptr<Decay> &) {
    return 8;
}

std::shared_ptr<DecayQuery> FfiConverterDecayQuery::lift(void *ptr) {
    return std::shared_ptr<DecayQuery>(new DecayQuery(ptr));
}

void *FfiConverterDecayQuery::lower(const std::shared_ptr<DecayQuery> &obj) {
    return obj->instance;
}

std::shared_ptr<DecayQuery> FfiConverterDecayQuery::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<DecayQuery>(new DecayQuery(reinterpret_cast<void *>(ptr)));
}

void FfiConverterDecayQuery::write(RustStream &stream, const std::shared_ptr<DecayQuery> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterDecayQuery::allocation_size(const std::shared_ptr<DecayQuery> &) {
    return 8;
}

std::shared_ptr<Duration> FfiConverterDuration::lift(void *ptr) {
    return std::shared_ptr<Duration>(new Duration(ptr));
}

void *FfiConverterDuration::lower(const std::shared_ptr<Duration> &obj) {
    return obj->instance;
}

std::shared_ptr<Duration> FfiConverterDuration::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Duration>(new Duration(reinterpret_cast<void *>(ptr)));
}

void FfiConverterDuration::write(RustStream &stream, const std::shared_ptr<Duration> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterDuration::allocation_size(const std::shared_ptr<Duration> &) {
    return 8;
}

std::shared_ptr<EncryptedString> FfiConverterEncryptedString::lift(void *ptr) {
    return std::shared_ptr<EncryptedString>(new EncryptedString(ptr));
}

void *FfiConverterEncryptedString::lower(const std::shared_ptr<EncryptedString> &obj) {
    return obj->instance;
}

std::shared_ptr<EncryptedString> FfiConverterEncryptedString::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<EncryptedString>(new EncryptedString(reinterpret_cast<void *>(ptr)));
}

void FfiConverterEncryptedString::write(RustStream &stream,
                                        const std::shared_ptr<EncryptedString> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterEncryptedString::allocation_size(const std::shared_ptr<EncryptedString> &) {
    return 8;
}

std::shared_ptr<Identity> FfiConverterIdentity::lift(void *ptr) {
    return std::shared_ptr<Identity>(new Identity(ptr));
}

void *FfiConverterIdentity::lower(const std::shared_ptr<Identity> &obj) {
    return obj->instance;
}

std::shared_ptr<Identity> FfiConverterIdentity::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Identity>(new Identity(reinterpret_cast<void *>(ptr)));
}

void FfiConverterIdentity::write(RustStream &stream, const std::shared_ptr<Identity> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterIdentity::allocation_size(const std::shared_ptr<Identity> &) {
    return 8;
}

std::shared_ptr<Ping> FfiConverterPing::lift(void *ptr) {
    return std::shared_ptr<Ping>(new Ping(ptr));
}

void *FfiConverterPing::lower(const std::shared_ptr<Ping> &obj) {
    return obj->instance;
}

std::shared_ptr<Ping> FfiConverterPing::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Ping>(new Ping(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPing::write(RustStream &stream, const std::shared_ptr<Ping> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPing::allocation_size(const std::shared_ptr<Ping> &) {
    return 8;
}

std::shared_ptr<Ping2> FfiConverterPing2::lift(void *ptr) {
    return std::shared_ptr<Ping2>(new Ping2(ptr));
}

void *FfiConverterPing2::lower(const std::shared_ptr<Ping2> &obj) {
    return obj->instance;
}

std::shared_ptr<Ping2> FfiConverterPing2::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Ping2>(new Ping2(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPing2::write(RustStream &stream, const std::shared_ptr<Ping2> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPing2::allocation_size(const std::shared_ptr<Ping2> &) {
    return 8;
}

std::shared_ptr<PlayerId> FfiConverterPlayerId::lift(void *ptr) {
    return std::shared_ptr<PlayerId>(new PlayerId(ptr));
}

void *FfiConverterPlayerId::lower(const std::shared_ptr<PlayerId> &obj) {
    return obj->instance;
}

std::shared_ptr<PlayerId> FfiConverterPlayerId::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<PlayerId>(new PlayerId(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPlayerId::write(RustStream &stream, const std::shared_ptr<PlayerId> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPlayerId::allocation_size(const std::shared_ptr<PlayerId> &) {
    return 8;
}

std::shared_ptr<PrivateKey> FfiConverterPrivateKey::lift(void *ptr) {
    return std::shared_ptr<PrivateKey>(new PrivateKey(ptr));
}

void *FfiConverterPrivateKey::lower(const std::shared_ptr<PrivateKey> &obj) {
    return obj->instance;
}

std::shared_ptr<PrivateKey> FfiConverterPrivateKey::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<PrivateKey>(new PrivateKey(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPrivateKey::write(RustStream &stream, const std::shared_ptr<PrivateKey> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPrivateKey::allocation_size(const std::shared_ptr<PrivateKey> &) {
    return 8;
}

std::shared_ptr<PublicKey> FfiConverterPublicKey::lift(void *ptr) {
    return std::shared_ptr<PublicKey>(new PublicKey(ptr));
}

void *FfiConverterPublicKey::lower(const std::shared_ptr<PublicKey> &obj) {
    return obj->instance;
}

std::shared_ptr<PublicKey> FfiConverterPublicKey::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<PublicKey>(new PublicKey(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPublicKey::write(RustStream &stream, const std::shared_ptr<PublicKey> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPublicKey::allocation_size(const std::shared_ptr<PublicKey> &) {
    return 8;
}

std::shared_ptr<Serializable> FfiConverterSerializable::lift(void *ptr) {
    return std::shared_ptr<Serializable>(new Serializable(ptr));
}

void *FfiConverterSerializable::lower(const std::shared_ptr<Serializable> &obj) {
    return obj->instance;
}

std::shared_ptr<Serializable> FfiConverterSerializable::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Serializable>(new Serializable(reinterpret_cast<void *>(ptr)));
}

void FfiConverterSerializable::write(RustStream &stream, const std::shared_ptr<Serializable> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterSerializable::allocation_size(const std::shared_ptr<Serializable> &) {
    return 8;
}

std::shared_ptr<ServerError> FfiConverterServerError::lift(void *ptr) {
    return std::shared_ptr<ServerError>(new ServerError(ptr));
}

void *FfiConverterServerError::lower(const std::shared_ptr<ServerError> &obj) {
    return obj->instance;
}

std::shared_ptr<ServerError> FfiConverterServerError::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<ServerError>(new ServerError(reinterpret_cast<void *>(ptr)));
}

void FfiConverterServerError::write(RustStream &stream, const std::shared_ptr<ServerError> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterServerError::allocation_size(const std::shared_ptr<ServerError> &) {
    return 8;
}

std::shared_ptr<ServerStatus> FfiConverterServerStatus::lift(void *ptr) {
    return std::shared_ptr<ServerStatus>(new ServerStatus(ptr));
}

void *FfiConverterServerStatus::lower(const std::shared_ptr<ServerStatus> &obj) {
    return obj->instance;
}

std::shared_ptr<ServerStatus> FfiConverterServerStatus::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<ServerStatus>(new ServerStatus(reinterpret_cast<void *>(ptr)));
}

void FfiConverterServerStatus::write(RustStream &stream, const std::shared_ptr<ServerStatus> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterServerStatus::allocation_size(const std::shared_ptr<ServerStatus> &) {
    return 8;
}

std::shared_ptr<ServerTimestamp> FfiConverterServerTimestamp::lift(void *ptr) {
    return std::shared_ptr<ServerTimestamp>(new ServerTimestamp(ptr));
}

void *FfiConverterServerTimestamp::lower(const std::shared_ptr<ServerTimestamp> &obj) {
    return obj->instance;
}

std::shared_ptr<ServerTimestamp> FfiConverterServerTimestamp::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<ServerTimestamp>(new ServerTimestamp(reinterpret_cast<void *>(ptr)));
}

void FfiConverterServerTimestamp::write(RustStream &stream,
                                        const std::shared_ptr<ServerTimestamp> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterServerTimestamp::allocation_size(const std::shared_ptr<ServerTimestamp> &) {
    return 8;
}

std::shared_ptr<SyncedTimestamp> FfiConverterSyncedTimestamp::lift(void *ptr) {
    return std::shared_ptr<SyncedTimestamp>(new SyncedTimestamp(ptr));
}

void *FfiConverterSyncedTimestamp::lower(const std::shared_ptr<SyncedTimestamp> &obj) {
    return obj->instance;
}

std::shared_ptr<SyncedTimestamp> FfiConverterSyncedTimestamp::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<SyncedTimestamp>(new SyncedTimestamp(reinterpret_cast<void *>(ptr)));
}

void FfiConverterSyncedTimestamp::write(RustStream &stream,
                                        const std::shared_ptr<SyncedTimestamp> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterSyncedTimestamp::allocation_size(const std::shared_ptr<SyncedTimestamp> &) {
    return 8;
}

std::shared_ptr<Timestamp> FfiConverterTimestamp::lift(void *ptr) {
    return std::shared_ptr<Timestamp>(new Timestamp(ptr));
}

void *FfiConverterTimestamp::lower(const std::shared_ptr<Timestamp> &obj) {
    return obj->instance;
}

std::shared_ptr<Timestamp> FfiConverterTimestamp::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Timestamp>(new Timestamp(reinterpret_cast<void *>(ptr)));
}

void FfiConverterTimestamp::write(RustStream &stream, const std::shared_ptr<Timestamp> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterTimestamp::allocation_size(const std::shared_ptr<Timestamp> &) {
    return 8;
}

Keys FfiConverterTypeKeys::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeKeys::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeKeys::lower(const Keys &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeKeys::write(stream, val);

    return std::move(buf);
}

Keys FfiConverterTypeKeys::read(RustStream &stream) {
    return {FfiConverterPublicKey::read(stream), FfiConverterPrivateKey::read(stream)};
}

void FfiConverterTypeKeys::write(RustStream &stream, const Keys &val) {
    FfiConverterPublicKey::write(stream, val.public_key);
    FfiConverterPrivateKey::write(stream, val.private_key);
}

int32_t FfiConverterTypeKeys::allocation_size(const Keys &val) {

    return FfiConverterPublicKey::allocation_size(val.public_key) +
           FfiConverterPrivateKey::allocation_size(val.private_key);
}

std::unique_ptr<EncryptionError> FfiConverterTypeEncryptionError::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEncryptionError::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterTypeEncryptionError::lower(const EncryptionError &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEncryptionError::write(stream, val);

    return std::move(buf);
}

std::unique_ptr<EncryptionError> FfiConverterTypeEncryptionError::read(RustStream &stream) {
    int32_t v;
    stream >> v;

    switch (v) {
    case 1: {
        encryption_error::InvalidData var;
        return std::make_unique<encryption_error::InvalidData>(var);
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

void FfiConverterTypeEncryptionError::write(RustStream &stream, const EncryptionError &val) {
    stream << val.get_variant_idx();
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const encryption_error::InvalidData &>(val);
        break;
    }
    }
}

int32_t FfiConverterTypeEncryptionError::allocation_size(const EncryptionError &val) {
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const encryption_error::InvalidData &>(val);
        return static_cast<int32_t>(sizeof(int32_t));
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

ErrorCode FfiConverterTypeErrorCode::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeErrorCode::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeErrorCode::lower(const ErrorCode &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeErrorCode::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeErrorCode::write(stream, val);

    return std::move(buf);
}

ErrorCode FfiConverterTypeErrorCode::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {

    case 1:
        return ErrorCode::kAuthenticationError;

    case 2:
        return ErrorCode::kSerializationError;

    case 3:
        return ErrorCode::kInvalidData;

    case 4:
        return ErrorCode::kIoError;

    case 5:
        return ErrorCode::kServerError;

    default:
        throw std::runtime_error("No matching ErrorCode variant");
    }
}

void FfiConverterTypeErrorCode::write(RustStream &stream, const ErrorCode &val) {
    switch (val) {

    case ErrorCode::kAuthenticationError:
        stream << static_cast<int32_t>(1);
        break;

    case ErrorCode::kSerializationError:
        stream << static_cast<int32_t>(2);
        break;

    case ErrorCode::kInvalidData:
        stream << static_cast<int32_t>(3);
        break;

    case ErrorCode::kIoError:
        stream << static_cast<int32_t>(4);
        break;

    case ErrorCode::kServerError:
        stream << static_cast<int32_t>(5);
        break;

    default:
        throw std::runtime_error("No matching ErrorCode variant");
    }
}

int32_t FfiConverterTypeErrorCode::allocation_size(const ErrorCode &) {
    return static_cast<int32_t>(sizeof(int32_t));
}

SafeString FfiConverterTypeSafeString::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSafeString::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSafeString::lower(const SafeString &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeSafeString::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSafeString::write(stream, val);

    return std::move(buf);
}

SafeString FfiConverterTypeSafeString::read(RustStream &stream) {
    int32_t variant_id;
    stream >> variant_id;

    switch (variant_id) {

    case 1:
        return SafeString::kEncrypted{
            .data = FfiConverterEncryptedString::read(stream),
        };

    case 2:
        return SafeString::kPlaintext{
            .value = FfiConverterString::read(stream),
        };

    default:
        throw std::runtime_error("No matching SafeString variant");
    }
}

void FfiConverterTypeSafeString::write(RustStream &stream, const SafeString &val) {
    int32_t variant_id = static_cast<int32_t>(val.variant.index() + 1);

    stream << variant_id;

    std::visit(
        [&](auto &&arg) {
            using T = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<T, SafeString::kEncrypted>) {
                FfiConverterEncryptedString::write(stream, arg.data);
            } else if constexpr (std::is_same_v<T, SafeString::kPlaintext>) {
                FfiConverterString::write(stream, arg.value);
            } else {
                static_assert(always_false_v<T>, "non-exhaustive SafeString visitor");
            }
        },
        val.variant);
}

int32_t FfiConverterTypeSafeString::allocation_size(const SafeString &val) {
    int32_t size = sizeof(int32_t);

    size += std::visit(
        [&](auto &&arg) {
            using T = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<T, SafeString::kEncrypted>) {
                int32_t size = 0;
                size += FfiConverterEncryptedString::allocation_size(arg.data);
                return size;
            } else if constexpr (std::is_same_v<T, SafeString::kPlaintext>) {
                int32_t size = 0;
                size += FfiConverterString::allocation_size(arg.value);
                return size;
            } else {
                static_assert(always_false_v<T>, "non-exhaustive SafeString visitor");
            }

            return 0;
        },
        val.variant);

    return size;
}

std::unique_ptr<SerializationError> FfiConverterTypeSerializationError::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSerializationError::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterTypeSerializationError::lower(const SerializationError &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSerializationError::write(stream, val);

    return std::move(buf);
}

std::unique_ptr<SerializationError> FfiConverterTypeSerializationError::read(RustStream &stream) {
    int32_t v;
    stream >> v;

    switch (v) {
    case 1: {
        serialization_error::BadData var;
        var.msg = FfiConverterString::read(stream);
        return std::make_unique<serialization_error::BadData>(var);
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

void FfiConverterTypeSerializationError::write(RustStream &stream, const SerializationError &val) {
    stream << val.get_variant_idx();
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const serialization_error::BadData &>(val);
        FfiConverterString::write(stream, var.msg);
        break;
    }
    }
}

int32_t FfiConverterTypeSerializationError::allocation_size(const SerializationError &val) {
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const serialization_error::BadData &>(val);
        return static_cast<int32_t>(sizeof(int32_t) + FfiConverterString::allocation_size(var.msg));
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

Status FfiConverterTypeStatus::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeStatus::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeStatus::lower(const Status &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeStatus::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeStatus::write(stream, val);

    return std::move(buf);
}

Status FfiConverterTypeStatus::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {

    case 1:
        return Status::kOk;

    default:
        throw std::runtime_error("No matching Status variant");
    }
}

void FfiConverterTypeStatus::write(RustStream &stream, const Status &val) {
    switch (val) {

    case Status::kOk:
        stream << static_cast<int32_t>(1);
        break;

    default:
        throw std::runtime_error("No matching Status variant");
    }
}

int32_t FfiConverterTypeStatus::allocation_size(const Status &) {
    return static_cast<int32_t>(sizeof(int32_t));
}

std::optional<std::string> FfiConverterOptionalString::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalString::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalString::lower(const std::optional<std::string> &val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalString::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalString::write(stream, val);

    return buf;
}

std::optional<std::string> FfiConverterOptionalString::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterString::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalString::write(RustStream &stream,
                                       const std::optional<std::string> &value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterString::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalString::allocation_size(const std::optional<std::string> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterString::allocation_size(val.value());
    }

    return ret;
}

} // namespace uniffi

std::string decay_message_tag() {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_decay_message_tag, nullptr);

    return uniffi::FfiConverterString::lift(ret);
}

std::string server_error_message_tag() {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_servererror_message_tag, nullptr);

    return uniffi::FfiConverterString::lift(ret);
}

std::string server_status_message_tag() {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_serverstatus_message_tag, nullptr);

    return uniffi::FfiConverterString::lift(ret);
}

Keys generate_new_keys() {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_generate_new_keys, nullptr);

    return uniffi::FfiConverterTypeKeys::lift(ret);
}

uint8_t parse_request_id(const std::string &data) {
    auto ret = uniffi::rust_call(
        uniffi_logic_fn_func_parse_request_id, nullptr, uniffi::FfiConverterString::lower(data));

    return uniffi::FfiConverterUInt8::lift(ret);
}

std::string serialize_me(const std::shared_ptr<Serializable> &msg, uint8_t request_id) {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_serialize_me,
                                 uniffi::FfiConverterTypeSerializationError::lift,
                                 uniffi::FfiConverterSerializable::lower(msg),
                                 uniffi::FfiConverterUInt8::lower(request_id));

    return uniffi::FfiConverterString::lift(ret);
}
} // namespace logic