/* This file was generated by uniffi-bindgen-cpp. */
#include <string>

#include "logic.hpp"

namespace logic {
namespace uniffi {
template <class> inline constexpr bool always_false_v = false;

namespace {
void ensure_initialized() {
    auto bindings_contract_version = 24;
    auto scaffolding_contract_version = ffi_logic_uniffi_contract_version();

    if (bindings_contract_version != scaffolding_contract_version) {
        throw std::runtime_error(
            "UniFFI contract version mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_add() != 27736) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
}

// Note: we need this indirection here and can't inline this code in the rust_call function
// as it's a templated function
void initialize() {
    static std::once_flag init_flag;
    std::call_once(init_flag, ensure_initialized);
}
} // namespace

template <typename F> void check_rust_call(const RustCallStatus &status, F error_cb) {
    switch (status.code) {
    case 0:
        return;

    case 1:
        if constexpr (!std::is_null_pointer_v<F>) {
            error_cb(status.error_buf)->throw_underlying();
        }
        break;

    case 2:
        if (status.error_buf.len > 0) {
            throw std::runtime_error(FfiConverterString::lift(status.error_buf));
        }

        throw std::runtime_error("A Rust panic has occurred");
    }

    throw std::runtime_error("Unexpected Rust call status");
}

template <typename F,
          typename EF,
          typename... Args,
          typename R = std::invoke_result_t<F, Args..., RustCallStatus *>>
R rust_call(F f, EF error_cb, Args... args) {
    initialize();

    RustCallStatus status = {0};

    if constexpr (std::is_void_v<R>) {
        f(args..., &status);
        check_rust_call(status, error_cb);
    } else {
        auto ret = f(args..., &status);
        check_rust_call(status, error_cb);

        return ret;
    }
}

RustBuffer rustbuffer_alloc(int32_t len) {
    RustCallStatus status = {0};
    auto buffer = ffi_logic_rustbuffer_alloc(len, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

RustBuffer rustbuffer_from_bytes(const ForeignBytes &bytes) {
    RustCallStatus status = {0};
    auto buffer = ffi_logic_rustbuffer_from_bytes(bytes, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = {0};

    ffi_logic_rustbuffer_free(std::move(buf), &status);
    check_rust_call(status, nullptr);
}

uint32_t FfiConverterUInt32::lift(uint32_t val) {
    return val;
}

uint32_t FfiConverterUInt32::lower(uint32_t val) {
    return val;
}

uint32_t FfiConverterUInt32::read(RustStream &stream) {
    uint32_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt32::write(RustStream &stream, uint32_t val) {
    stream << val;
}

int32_t FfiConverterUInt32::allocation_size(uint32_t) {
    return static_cast<int32_t>(sizeof(uint32_t));
}
std::string FfiConverterString::lift(RustBuffer buf) {
    auto string = std::string(reinterpret_cast<char *>(buf.data), buf.len);

    rustbuffer_free(buf);

    return string;
}

RustBuffer FfiConverterString::lower(const std::string &val) {
    auto len = static_cast<int32_t>(val.length());
    auto bytes = ForeignBytes{len, reinterpret_cast<uint8_t *>(const_cast<char *>(val.data()))};

    return rustbuffer_from_bytes(bytes);
}

std::string FfiConverterString::read(RustStream &stream) {
    int32_t len;
    std::string string;

    stream >> len;

    string.resize(len);
    stream.read(string.data(), len);

    return string;
}

void FfiConverterString::write(RustStream &stream, const std::string &val) {
    stream << static_cast<int32_t>(val.length());
    stream.write(val.data(), val.length());
}

int32_t FfiConverterString::allocation_size(const std::string &val) {
    return static_cast<int32_t>(sizeof(int32_t) + val.length());
}
} // namespace uniffi

namespace uniffi {}

uint32_t add(uint32_t a, uint32_t b) {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_add,
                                 nullptr,
                                 uniffi::FfiConverterUInt32::lower(a),
                                 uniffi::FfiConverterUInt32::lower(b));

    return uniffi::FfiConverterUInt32::lift(ret);
}
} // namespace logic