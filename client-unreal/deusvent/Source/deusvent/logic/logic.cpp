#pragma clang diagnostic ignored "-Wpessimizing-move"
/* This file was generated by uniffi-bindgen-cpp. */
#include <string>

#include "logic.hpp"

namespace logic {
namespace uniffi {
template <class> inline constexpr bool always_false_v = false;

namespace {
void ensure_initialized() {
    auto bindings_contract_version = 24;
    auto scaffolding_contract_version = ffi_logic_uniffi_contract_version();

    if (bindings_contract_version != scaffolding_contract_version) {
        throw std::runtime_error(
            "UniFFI contract version mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_decay_message_tag() != 47840) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_servererror_message_tag() != 13551) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_serverstatus_message_tag() != 55415) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_generate_new_keys() != 64904) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decayqueryserializer_data() != 33162) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decayqueryserializer_debug_string() != 47777) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decayqueryserializer_serialize() != 33971) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decayserializer_data() != 64473) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decayserializer_debug_string() != 9727) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decayserializer_request_id() != 11361) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_decayserializer_serialize() != 16638) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_duration_whole_days() != 58703) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_duration_whole_hours() != 60524) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_duration_whole_minutes() != 14664) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_encryptedstring_decrypt() != 14315) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_identityserializer_data() != 35595) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_identityserializer_debug_string() != 33099) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_identityserializer_serialize() != 51396) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_pingserializer_data() != 55445) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_pingserializer_debug_string() != 9881) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_pingserializer_serialize() != 7217) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_privatekey_serialize() != 39381) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_publickey_as_string() != 5145) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_publickey_serialize() != 18621) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererrorserializer_data() != 16039) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererrorserializer_debug_string() != 25135) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererrorserializer_request_id() != 30047) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servererrorserializer_serialize() != 1802) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatusserializer_data() != 48664) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatusserializer_debug_string() != 1117) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatusserializer_request_id() != 776) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatusserializer_serialize() != 51972) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servertimestamp_as_string() != 29463) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_syncedtimestamp_adjust() != 41584) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_syncedtimestamp_now() != 943) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_timestamp_as_string() != 3604) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_timestamp_diff() != 48627) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_decayqueryserializer_deserialize() != 46193) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_decayqueryserializer_new() != 28331) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_decayserializer_deserialize() != 341) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_decayserializer_new() != 10606) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_duration_from_milliseconds() != 62484) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_encryptedstring_new() != 41058) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_identityserializer_deserialize() != 32642) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_identityserializer_new() != 4284) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_pingserializer_deserialize() != 44314) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_pingserializer_new() != 20928) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_privatekey_deserialize() != 51694) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_publickey_deserialize() != 26224) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_servererrorserializer_deserialize() != 58731) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_servererrorserializer_new() != 47355) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_serverstatusserializer_deserialize() != 18349) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_serverstatusserializer_new() != 54043) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_servertimestamp_from_milliseconds() != 5946) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_syncedtimestamp_new() != 19626) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_timestamp_from_milliseconds() != 19208) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_timestamp_now() != 17293) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
}

// Note: we need this indirection here and can't inline this code in the rust_call function
// as it's a templated function
void initialize() {
    static std::once_flag init_flag;
    std::call_once(init_flag, ensure_initialized);
}
} // namespace

template <typename F> void check_rust_call(const RustCallStatus &status, F error_cb) {
    switch (status.code) {
    case 0:
        return;

    case 1:
        if constexpr (!std::is_null_pointer_v<F>) {
            error_cb(status.error_buf)->throw_underlying();
        }
        break;

    case 2:
        if (status.error_buf.len > 0) {
            throw std::runtime_error(FfiConverterString::lift(status.error_buf));
        }

        throw std::runtime_error("A Rust panic has occurred");
    }

    throw std::runtime_error("Unexpected Rust call status");
}

template <typename F,
          typename EF,
          typename... Args,
          typename R = std::invoke_result_t<F, Args..., RustCallStatus *>>
R rust_call(F f, EF error_cb, Args... args) {
    initialize();

    RustCallStatus status = {0};

    if constexpr (std::is_void_v<R>) {
        f(args..., &status);
        check_rust_call(status, error_cb);
    } else {
        auto ret = f(args..., &status);
        check_rust_call(status, error_cb);

        return ret;
    }
}

RustBuffer rustbuffer_alloc(int32_t len) {
    RustCallStatus status = {0};
    auto buffer = ffi_logic_rustbuffer_alloc(len, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

RustBuffer rustbuffer_from_bytes(const ForeignBytes &bytes) {
    RustCallStatus status = {0};
    auto buffer = ffi_logic_rustbuffer_from_bytes(bytes, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = {0};

    ffi_logic_rustbuffer_free(std::move(buf), &status);
    check_rust_call(status, nullptr);
}

uint8_t FfiConverterUInt8::lift(uint8_t val) {
    return val;
}

uint8_t FfiConverterUInt8::lower(uint8_t val) {
    return val;
}

uint8_t FfiConverterUInt8::read(RustStream &stream) {
    uint8_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt8::write(RustStream &stream, uint8_t val) {
    stream << val;
}

int32_t FfiConverterUInt8::allocation_size(uint8_t) {
    return static_cast<int32_t>(sizeof(uint8_t));
}
uint16_t FfiConverterUInt16::lift(uint16_t val) {
    return val;
}

uint16_t FfiConverterUInt16::lower(uint16_t val) {
    return val;
}

uint16_t FfiConverterUInt16::read(RustStream &stream) {
    uint16_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt16::write(RustStream &stream, uint16_t val) {
    stream << val;
}

int32_t FfiConverterUInt16::allocation_size(uint16_t) {
    return static_cast<int32_t>(sizeof(uint16_t));
}
uint64_t FfiConverterUInt64::lift(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::lower(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::read(RustStream &stream) {
    uint64_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt64::write(RustStream &stream, uint64_t val) {
    stream << val;
}

int32_t FfiConverterUInt64::allocation_size(uint64_t) {
    return static_cast<int32_t>(sizeof(uint64_t));
}

bool FfiConverterBool::lift(uint8_t val) {
    return !!val;
}

uint8_t FfiConverterBool::lower(bool val) {
    return val;
}

bool FfiConverterBool::read(RustStream &stream) {
    uint8_t val;
    stream >> val;

    return val;
}

void FfiConverterBool::write(RustStream &stream, bool val) {
    stream << val;
}

int32_t FfiConverterBool::allocation_size(bool) {
    return 1;
}
std::string FfiConverterString::lift(RustBuffer buf) {
    auto string = std::string(reinterpret_cast<char *>(buf.data), buf.len);

    rustbuffer_free(buf);

    return string;
}

RustBuffer FfiConverterString::lower(const std::string &val) {
    auto len = static_cast<int32_t>(val.length());
    auto bytes = ForeignBytes{len, reinterpret_cast<uint8_t *>(const_cast<char *>(val.data()))};

    return rustbuffer_from_bytes(bytes);
}

std::string FfiConverterString::read(RustStream &stream) {
    int32_t len;
    std::string string;

    stream >> len;

    string.resize(len);
    stream.read(string.data(), len);

    return string;
}

void FfiConverterString::write(RustStream &stream, const std::string &val) {
    stream << static_cast<int32_t>(val.length());
    stream.write(val.data(), val.length());
}

int32_t FfiConverterString::allocation_size(const std::string &val) {
    return static_cast<int32_t>(sizeof(int32_t) + val.length());
}

std::vector<uint8_t> FfiConverterBytes::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterBytes::lower(const std::vector<uint8_t> &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    write(stream, val);

    return buf;
}

std::vector<uint8_t> FfiConverterBytes::read(RustStream &stream) {
    std::vector<uint8_t> ret;
    int32_t count;
    stream >> count;

    ret.reserve(count);

    for (decltype(count) i = 0; i < count; i++) {
        uint8_t elem;
        stream >> elem;
        ret.push_back(elem);
    }

    return ret;
}

void FfiConverterBytes::write(RustStream &stream, const std::vector<uint8_t> &val) {
    stream << static_cast<int32_t>(val.size());

    for (auto &elem : val) {
        stream << elem;
    }
}

int32_t FfiConverterBytes::allocation_size(const std::vector<uint8_t> &val) {
    return static_cast<int32_t>(sizeof(int32_t) + sizeof(uint8_t) * val.size());
}
} // namespace uniffi

DecayQuerySerializer::DecayQuerySerializer(void *ptr) : instance(ptr) {
}

std::shared_ptr<DecayQuerySerializer>
DecayQuerySerializer::init(const DecayQuery &data, const std::shared_ptr<PublicKey> &public_key) {
    return std::shared_ptr<DecayQuerySerializer>(new DecayQuerySerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_decayqueryserializer_new,
                          nullptr,
                          uniffi::FfiConverterTypeDecayQuery::lower(data),
                          uniffi::FfiConverterPublicKey::lower(public_key))));
}

std::shared_ptr<DecayQuerySerializer> DecayQuerySerializer::deserialize(const std::string &data) {
    return std::shared_ptr<DecayQuerySerializer>(new DecayQuerySerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_decayqueryserializer_deserialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          uniffi::FfiConverterString::lower(data))));
}

DecayQuery DecayQuerySerializer::data() {
    return uniffi::FfiConverterTypeDecayQuery::lift(uniffi::rust_call(
        uniffi_logic_fn_method_decayqueryserializer_data, nullptr, this->instance));
}
std::string DecayQuerySerializer::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_decayqueryserializer_debug_string, nullptr, this->instance));
}
std::string DecayQuerySerializer::serialize(uint8_t request_id,
                                            const std::shared_ptr<PrivateKey> &private_key) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_decayqueryserializer_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id),
                          uniffi::FfiConverterPrivateKey::lower(private_key)));
}

DecayQuerySerializer::~DecayQuerySerializer() {
    uniffi::rust_call(uniffi_logic_fn_free_decayqueryserializer, nullptr, this->instance);
}

DecaySerializer::DecaySerializer(void *ptr) : instance(ptr) {
}

std::shared_ptr<DecaySerializer> DecaySerializer::init(const Decay &data) {
    return std::shared_ptr<DecaySerializer>(
        new DecaySerializer(uniffi::rust_call(uniffi_logic_fn_constructor_decayserializer_new,
                                              nullptr,
                                              uniffi::FfiConverterTypeDecay::lower(data))));
}

std::shared_ptr<DecaySerializer> DecaySerializer::deserialize(const std::string &data) {
    return std::shared_ptr<DecaySerializer>(new DecaySerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_decayserializer_deserialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          uniffi::FfiConverterString::lower(data))));
}

Decay DecaySerializer::data() {
    return uniffi::FfiConverterTypeDecay::lift(
        uniffi::rust_call(uniffi_logic_fn_method_decayserializer_data, nullptr, this->instance));
}
std::string DecaySerializer::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_decayserializer_debug_string, nullptr, this->instance));
}
uint8_t DecaySerializer::request_id() {
    return uniffi::FfiConverterUInt8::lift(uniffi::rust_call(
        uniffi_logic_fn_method_decayserializer_request_id, nullptr, this->instance));
}
std::string DecaySerializer::serialize(uint8_t request_id) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_decayserializer_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id)));
}

DecaySerializer::~DecaySerializer() {
    uniffi::rust_call(uniffi_logic_fn_free_decayserializer, nullptr, this->instance);
}

Duration::Duration(void *ptr) : instance(ptr) {
}

std::shared_ptr<Duration> Duration::from_milliseconds(uint64_t milliseconds) {
    return std::shared_ptr<Duration>(
        new Duration(uniffi::rust_call(uniffi_logic_fn_constructor_duration_from_milliseconds,
                                       nullptr,
                                       uniffi::FfiConverterUInt64::lower(milliseconds))));
}

uint64_t Duration::whole_days() {
    return uniffi::FfiConverterUInt64::lift(
        uniffi::rust_call(uniffi_logic_fn_method_duration_whole_days, nullptr, this->instance));
}
uint64_t Duration::whole_hours() {
    return uniffi::FfiConverterUInt64::lift(
        uniffi::rust_call(uniffi_logic_fn_method_duration_whole_hours, nullptr, this->instance));
}
uint64_t Duration::whole_minutes() {
    return uniffi::FfiConverterUInt64::lift(
        uniffi::rust_call(uniffi_logic_fn_method_duration_whole_minutes, nullptr, this->instance));
}

Duration::~Duration() {
    uniffi::rust_call(uniffi_logic_fn_free_duration, nullptr, this->instance);
}

EncryptedString::EncryptedString(void *ptr) : instance(ptr) {
}

std::shared_ptr<EncryptedString>
EncryptedString::init(const std::string &plaintext,
                      const std::shared_ptr<PrivateKey> &private_key) {
    return std::shared_ptr<EncryptedString>(
        new EncryptedString(uniffi::rust_call(uniffi_logic_fn_constructor_encryptedstring_new,
                                              nullptr,
                                              uniffi::FfiConverterString::lower(plaintext),
                                              uniffi::FfiConverterPrivateKey::lower(private_key))));
}

std::string EncryptedString::decrypt(const std::shared_ptr<PrivateKey> &private_key) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_encryptedstring_decrypt,
                          uniffi::FfiConverterTypeEncryptionError::lift,
                          this->instance,
                          uniffi::FfiConverterPrivateKey::lower(private_key)));
}

EncryptedString::~EncryptedString() {
    uniffi::rust_call(uniffi_logic_fn_free_encryptedstring, nullptr, this->instance);
}

IdentitySerializer::IdentitySerializer(void *ptr) : instance(ptr) {
}

std::shared_ptr<IdentitySerializer>
IdentitySerializer::init(const Identity &data, const std::shared_ptr<PublicKey> &public_key) {
    return std::shared_ptr<IdentitySerializer>(new IdentitySerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_identityserializer_new,
                          nullptr,
                          uniffi::FfiConverterTypeIdentity::lower(data),
                          uniffi::FfiConverterPublicKey::lower(public_key))));
}

std::shared_ptr<IdentitySerializer> IdentitySerializer::deserialize(const std::string &data) {
    return std::shared_ptr<IdentitySerializer>(new IdentitySerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_identityserializer_deserialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          uniffi::FfiConverterString::lower(data))));
}

Identity IdentitySerializer::data() {
    return uniffi::FfiConverterTypeIdentity::lift(
        uniffi::rust_call(uniffi_logic_fn_method_identityserializer_data, nullptr, this->instance));
}
std::string IdentitySerializer::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_identityserializer_debug_string, nullptr, this->instance));
}
std::string IdentitySerializer::serialize(uint8_t request_id,
                                          const std::shared_ptr<PrivateKey> &private_key) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_identityserializer_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id),
                          uniffi::FfiConverterPrivateKey::lower(private_key)));
}

IdentitySerializer::~IdentitySerializer() {
    uniffi::rust_call(uniffi_logic_fn_free_identityserializer, nullptr, this->instance);
}

PingSerializer::PingSerializer(void *ptr) : instance(ptr) {
}

std::shared_ptr<PingSerializer> PingSerializer::init(const Ping &data) {
    return std::shared_ptr<PingSerializer>(
        new PingSerializer(uniffi::rust_call(uniffi_logic_fn_constructor_pingserializer_new,
                                             nullptr,
                                             uniffi::FfiConverterTypePing::lower(data))));
}

std::shared_ptr<PingSerializer> PingSerializer::deserialize(const std::string &data) {
    return std::shared_ptr<PingSerializer>(
        new PingSerializer(uniffi::rust_call(uniffi_logic_fn_constructor_pingserializer_deserialize,
                                             uniffi::FfiConverterTypeSerializationError::lift,
                                             uniffi::FfiConverterString::lower(data))));
}

Ping PingSerializer::data() {
    return uniffi::FfiConverterTypePing::lift(
        uniffi::rust_call(uniffi_logic_fn_method_pingserializer_data, nullptr, this->instance));
}
std::string PingSerializer::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_pingserializer_debug_string, nullptr, this->instance));
}
std::string PingSerializer::serialize(uint8_t request_id) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_pingserializer_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id)));
}

PingSerializer::~PingSerializer() {
    uniffi::rust_call(uniffi_logic_fn_free_pingserializer, nullptr, this->instance);
}

PlayerId::PlayerId(void *ptr) : instance(ptr) {
}

PlayerId::~PlayerId() {
    uniffi::rust_call(uniffi_logic_fn_free_playerid, nullptr, this->instance);
}

PrivateKey::PrivateKey(void *ptr) : instance(ptr) {
}

std::shared_ptr<PrivateKey> PrivateKey::deserialize(const std::vector<uint8_t> &data) {
    return std::shared_ptr<PrivateKey>(
        new PrivateKey(uniffi::rust_call(uniffi_logic_fn_constructor_privatekey_deserialize,
                                         uniffi::FfiConverterTypeSerializationError::lift,
                                         uniffi::FfiConverterBytes::lower(data))));
}

std::vector<uint8_t> PrivateKey::serialize() {
    return uniffi::FfiConverterBytes::lift(
        uniffi::rust_call(uniffi_logic_fn_method_privatekey_serialize, nullptr, this->instance));
}

PrivateKey::~PrivateKey() {
    uniffi::rust_call(uniffi_logic_fn_free_privatekey, nullptr, this->instance);
}

PublicKey::PublicKey(void *ptr) : instance(ptr) {
}

std::shared_ptr<PublicKey> PublicKey::deserialize(const std::vector<uint8_t> &data) {
    return std::shared_ptr<PublicKey>(
        new PublicKey(uniffi::rust_call(uniffi_logic_fn_constructor_publickey_deserialize,
                                        uniffi::FfiConverterTypeSerializationError::lift,
                                        uniffi::FfiConverterBytes::lower(data))));
}

std::string PublicKey::as_string() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_publickey_as_string, nullptr, this->instance));
}
std::vector<uint8_t> PublicKey::serialize() {
    return uniffi::FfiConverterBytes::lift(
        uniffi::rust_call(uniffi_logic_fn_method_publickey_serialize, nullptr, this->instance));
}

PublicKey::~PublicKey() {
    uniffi::rust_call(uniffi_logic_fn_free_publickey, nullptr, this->instance);
}

ServerErrorSerializer::ServerErrorSerializer(void *ptr) : instance(ptr) {
}

std::shared_ptr<ServerErrorSerializer> ServerErrorSerializer::init(const ServerError &data) {
    return std::shared_ptr<ServerErrorSerializer>(new ServerErrorSerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_servererrorserializer_new,
                          nullptr,
                          uniffi::FfiConverterTypeServerError::lower(data))));
}

std::shared_ptr<ServerErrorSerializer> ServerErrorSerializer::deserialize(const std::string &data) {
    return std::shared_ptr<ServerErrorSerializer>(new ServerErrorSerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_servererrorserializer_deserialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          uniffi::FfiConverterString::lower(data))));
}

ServerError ServerErrorSerializer::data() {
    return uniffi::FfiConverterTypeServerError::lift(uniffi::rust_call(
        uniffi_logic_fn_method_servererrorserializer_data, nullptr, this->instance));
}
std::string ServerErrorSerializer::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_servererrorserializer_debug_string, nullptr, this->instance));
}
uint8_t ServerErrorSerializer::request_id() {
    return uniffi::FfiConverterUInt8::lift(uniffi::rust_call(
        uniffi_logic_fn_method_servererrorserializer_request_id, nullptr, this->instance));
}
std::string ServerErrorSerializer::serialize(uint8_t request_id) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_servererrorserializer_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id)));
}

ServerErrorSerializer::~ServerErrorSerializer() {
    uniffi::rust_call(uniffi_logic_fn_free_servererrorserializer, nullptr, this->instance);
}

ServerStatusSerializer::ServerStatusSerializer(void *ptr) : instance(ptr) {
}

std::shared_ptr<ServerStatusSerializer> ServerStatusSerializer::init(const ServerStatus &data) {
    return std::shared_ptr<ServerStatusSerializer>(new ServerStatusSerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_serverstatusserializer_new,
                          nullptr,
                          uniffi::FfiConverterTypeServerStatus::lower(data))));
}

std::shared_ptr<ServerStatusSerializer>
ServerStatusSerializer::deserialize(const std::string &data) {
    return std::shared_ptr<ServerStatusSerializer>(new ServerStatusSerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_serverstatusserializer_deserialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          uniffi::FfiConverterString::lower(data))));
}

ServerStatus ServerStatusSerializer::data() {
    return uniffi::FfiConverterTypeServerStatus::lift(uniffi::rust_call(
        uniffi_logic_fn_method_serverstatusserializer_data, nullptr, this->instance));
}
std::string ServerStatusSerializer::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_serverstatusserializer_debug_string, nullptr, this->instance));
}
uint8_t ServerStatusSerializer::request_id() {
    return uniffi::FfiConverterUInt8::lift(uniffi::rust_call(
        uniffi_logic_fn_method_serverstatusserializer_request_id, nullptr, this->instance));
}
std::string ServerStatusSerializer::serialize(uint8_t request_id) {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_serverstatusserializer_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance,
                          uniffi::FfiConverterUInt8::lower(request_id)));
}

ServerStatusSerializer::~ServerStatusSerializer() {
    uniffi::rust_call(uniffi_logic_fn_free_serverstatusserializer, nullptr, this->instance);
}

ServerTimestamp::ServerTimestamp(void *ptr) : instance(ptr) {
}

std::shared_ptr<ServerTimestamp> ServerTimestamp::from_milliseconds(uint64_t milliseconds) {
    return std::shared_ptr<ServerTimestamp>(new ServerTimestamp(
        uniffi::rust_call(uniffi_logic_fn_constructor_servertimestamp_from_milliseconds,
                          nullptr,
                          uniffi::FfiConverterUInt64::lower(milliseconds))));
}

std::string ServerTimestamp::as_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_servertimestamp_as_string, nullptr, this->instance));
}

ServerTimestamp::~ServerTimestamp() {
    uniffi::rust_call(uniffi_logic_fn_free_servertimestamp, nullptr, this->instance);
}

SyncedTimestamp::SyncedTimestamp(void *ptr) : instance(ptr) {
}

std::shared_ptr<SyncedTimestamp> SyncedTimestamp::init() {
    return std::shared_ptr<SyncedTimestamp>(new SyncedTimestamp(
        uniffi::rust_call(uniffi_logic_fn_constructor_syncedtimestamp_new, nullptr)));
}

void SyncedTimestamp::adjust(const std::shared_ptr<ServerTimestamp> &server_time,
                             const std::shared_ptr<Timestamp> &sent_at,
                             const std::shared_ptr<Timestamp> &received_at) {
    uniffi::rust_call(uniffi_logic_fn_method_syncedtimestamp_adjust,
                      nullptr,
                      this->instance,
                      uniffi::FfiConverterServerTimestamp::lower(server_time),
                      uniffi::FfiConverterTimestamp::lower(sent_at),
                      uniffi::FfiConverterTimestamp::lower(received_at));
}
std::shared_ptr<Timestamp> SyncedTimestamp::now() {
    return uniffi::FfiConverterTimestamp::lift(
        uniffi::rust_call(uniffi_logic_fn_method_syncedtimestamp_now, nullptr, this->instance));
}

SyncedTimestamp::~SyncedTimestamp() {
    uniffi::rust_call(uniffi_logic_fn_free_syncedtimestamp, nullptr, this->instance);
}

Timestamp::Timestamp(void *ptr) : instance(ptr) {
}

std::shared_ptr<Timestamp> Timestamp::from_milliseconds(uint64_t milliseconds) {
    return std::shared_ptr<Timestamp>(
        new Timestamp(uniffi::rust_call(uniffi_logic_fn_constructor_timestamp_from_milliseconds,
                                        nullptr,
                                        uniffi::FfiConverterUInt64::lower(milliseconds))));
}

std::shared_ptr<Timestamp> Timestamp::now() {
    return std::shared_ptr<Timestamp>(
        new Timestamp(uniffi::rust_call(uniffi_logic_fn_constructor_timestamp_now, nullptr)));
}

std::string Timestamp::as_string() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_timestamp_as_string, nullptr, this->instance));
}
std::shared_ptr<Duration> Timestamp::diff(const std::shared_ptr<Timestamp> &other) {
    return uniffi::FfiConverterDuration::lift(
        uniffi::rust_call(uniffi_logic_fn_method_timestamp_diff,
                          nullptr,
                          this->instance,
                          uniffi::FfiConverterTimestamp::lower(other)));
}

Timestamp::~Timestamp() {
    uniffi::rust_call(uniffi_logic_fn_free_timestamp, nullptr, this->instance);
}

namespace uniffi {

std::shared_ptr<DecayQuerySerializer> FfiConverterDecayQuerySerializer::lift(void *ptr) {
    return std::shared_ptr<DecayQuerySerializer>(new DecayQuerySerializer(ptr));
}

void *FfiConverterDecayQuerySerializer::lower(const std::shared_ptr<DecayQuerySerializer> &obj) {
    return obj->instance;
}

std::shared_ptr<DecayQuerySerializer> FfiConverterDecayQuerySerializer::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<DecayQuerySerializer>(
        new DecayQuerySerializer(reinterpret_cast<void *>(ptr)));
}

void FfiConverterDecayQuerySerializer::write(RustStream &stream,
                                             const std::shared_ptr<DecayQuerySerializer> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t
FfiConverterDecayQuerySerializer::allocation_size(const std::shared_ptr<DecayQuerySerializer> &) {
    return 8;
}

std::shared_ptr<DecaySerializer> FfiConverterDecaySerializer::lift(void *ptr) {
    return std::shared_ptr<DecaySerializer>(new DecaySerializer(ptr));
}

void *FfiConverterDecaySerializer::lower(const std::shared_ptr<DecaySerializer> &obj) {
    return obj->instance;
}

std::shared_ptr<DecaySerializer> FfiConverterDecaySerializer::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<DecaySerializer>(new DecaySerializer(reinterpret_cast<void *>(ptr)));
}

void FfiConverterDecaySerializer::write(RustStream &stream,
                                        const std::shared_ptr<DecaySerializer> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterDecaySerializer::allocation_size(const std::shared_ptr<DecaySerializer> &) {
    return 8;
}

std::shared_ptr<Duration> FfiConverterDuration::lift(void *ptr) {
    return std::shared_ptr<Duration>(new Duration(ptr));
}

void *FfiConverterDuration::lower(const std::shared_ptr<Duration> &obj) {
    return obj->instance;
}

std::shared_ptr<Duration> FfiConverterDuration::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Duration>(new Duration(reinterpret_cast<void *>(ptr)));
}

void FfiConverterDuration::write(RustStream &stream, const std::shared_ptr<Duration> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterDuration::allocation_size(const std::shared_ptr<Duration> &) {
    return 8;
}

std::shared_ptr<EncryptedString> FfiConverterEncryptedString::lift(void *ptr) {
    return std::shared_ptr<EncryptedString>(new EncryptedString(ptr));
}

void *FfiConverterEncryptedString::lower(const std::shared_ptr<EncryptedString> &obj) {
    return obj->instance;
}

std::shared_ptr<EncryptedString> FfiConverterEncryptedString::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<EncryptedString>(new EncryptedString(reinterpret_cast<void *>(ptr)));
}

void FfiConverterEncryptedString::write(RustStream &stream,
                                        const std::shared_ptr<EncryptedString> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterEncryptedString::allocation_size(const std::shared_ptr<EncryptedString> &) {
    return 8;
}

std::shared_ptr<IdentitySerializer> FfiConverterIdentitySerializer::lift(void *ptr) {
    return std::shared_ptr<IdentitySerializer>(new IdentitySerializer(ptr));
}

void *FfiConverterIdentitySerializer::lower(const std::shared_ptr<IdentitySerializer> &obj) {
    return obj->instance;
}

std::shared_ptr<IdentitySerializer> FfiConverterIdentitySerializer::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<IdentitySerializer>(
        new IdentitySerializer(reinterpret_cast<void *>(ptr)));
}

void FfiConverterIdentitySerializer::write(RustStream &stream,
                                           const std::shared_ptr<IdentitySerializer> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t
FfiConverterIdentitySerializer::allocation_size(const std::shared_ptr<IdentitySerializer> &) {
    return 8;
}

std::shared_ptr<PingSerializer> FfiConverterPingSerializer::lift(void *ptr) {
    return std::shared_ptr<PingSerializer>(new PingSerializer(ptr));
}

void *FfiConverterPingSerializer::lower(const std::shared_ptr<PingSerializer> &obj) {
    return obj->instance;
}

std::shared_ptr<PingSerializer> FfiConverterPingSerializer::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<PingSerializer>(new PingSerializer(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPingSerializer::write(RustStream &stream,
                                       const std::shared_ptr<PingSerializer> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPingSerializer::allocation_size(const std::shared_ptr<PingSerializer> &) {
    return 8;
}

std::shared_ptr<PlayerId> FfiConverterPlayerId::lift(void *ptr) {
    return std::shared_ptr<PlayerId>(new PlayerId(ptr));
}

void *FfiConverterPlayerId::lower(const std::shared_ptr<PlayerId> &obj) {
    return obj->instance;
}

std::shared_ptr<PlayerId> FfiConverterPlayerId::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<PlayerId>(new PlayerId(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPlayerId::write(RustStream &stream, const std::shared_ptr<PlayerId> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPlayerId::allocation_size(const std::shared_ptr<PlayerId> &) {
    return 8;
}

std::shared_ptr<PrivateKey> FfiConverterPrivateKey::lift(void *ptr) {
    return std::shared_ptr<PrivateKey>(new PrivateKey(ptr));
}

void *FfiConverterPrivateKey::lower(const std::shared_ptr<PrivateKey> &obj) {
    return obj->instance;
}

std::shared_ptr<PrivateKey> FfiConverterPrivateKey::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<PrivateKey>(new PrivateKey(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPrivateKey::write(RustStream &stream, const std::shared_ptr<PrivateKey> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPrivateKey::allocation_size(const std::shared_ptr<PrivateKey> &) {
    return 8;
}

std::shared_ptr<PublicKey> FfiConverterPublicKey::lift(void *ptr) {
    return std::shared_ptr<PublicKey>(new PublicKey(ptr));
}

void *FfiConverterPublicKey::lower(const std::shared_ptr<PublicKey> &obj) {
    return obj->instance;
}

std::shared_ptr<PublicKey> FfiConverterPublicKey::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<PublicKey>(new PublicKey(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPublicKey::write(RustStream &stream, const std::shared_ptr<PublicKey> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPublicKey::allocation_size(const std::shared_ptr<PublicKey> &) {
    return 8;
}

std::shared_ptr<ServerErrorSerializer> FfiConverterServerErrorSerializer::lift(void *ptr) {
    return std::shared_ptr<ServerErrorSerializer>(new ServerErrorSerializer(ptr));
}

void *FfiConverterServerErrorSerializer::lower(const std::shared_ptr<ServerErrorSerializer> &obj) {
    return obj->instance;
}

std::shared_ptr<ServerErrorSerializer> FfiConverterServerErrorSerializer::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<ServerErrorSerializer>(
        new ServerErrorSerializer(reinterpret_cast<void *>(ptr)));
}

void FfiConverterServerErrorSerializer::write(RustStream &stream,
                                              const std::shared_ptr<ServerErrorSerializer> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t
FfiConverterServerErrorSerializer::allocation_size(const std::shared_ptr<ServerErrorSerializer> &) {
    return 8;
}

std::shared_ptr<ServerStatusSerializer> FfiConverterServerStatusSerializer::lift(void *ptr) {
    return std::shared_ptr<ServerStatusSerializer>(new ServerStatusSerializer(ptr));
}

void *
FfiConverterServerStatusSerializer::lower(const std::shared_ptr<ServerStatusSerializer> &obj) {
    return obj->instance;
}

std::shared_ptr<ServerStatusSerializer>
FfiConverterServerStatusSerializer::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<ServerStatusSerializer>(
        new ServerStatusSerializer(reinterpret_cast<void *>(ptr)));
}

void FfiConverterServerStatusSerializer::write(RustStream &stream,
                                               const std::shared_ptr<ServerStatusSerializer> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterServerStatusSerializer::allocation_size(
    const std::shared_ptr<ServerStatusSerializer> &) {
    return 8;
}

std::shared_ptr<ServerTimestamp> FfiConverterServerTimestamp::lift(void *ptr) {
    return std::shared_ptr<ServerTimestamp>(new ServerTimestamp(ptr));
}

void *FfiConverterServerTimestamp::lower(const std::shared_ptr<ServerTimestamp> &obj) {
    return obj->instance;
}

std::shared_ptr<ServerTimestamp> FfiConverterServerTimestamp::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<ServerTimestamp>(new ServerTimestamp(reinterpret_cast<void *>(ptr)));
}

void FfiConverterServerTimestamp::write(RustStream &stream,
                                        const std::shared_ptr<ServerTimestamp> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterServerTimestamp::allocation_size(const std::shared_ptr<ServerTimestamp> &) {
    return 8;
}

std::shared_ptr<SyncedTimestamp> FfiConverterSyncedTimestamp::lift(void *ptr) {
    return std::shared_ptr<SyncedTimestamp>(new SyncedTimestamp(ptr));
}

void *FfiConverterSyncedTimestamp::lower(const std::shared_ptr<SyncedTimestamp> &obj) {
    return obj->instance;
}

std::shared_ptr<SyncedTimestamp> FfiConverterSyncedTimestamp::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<SyncedTimestamp>(new SyncedTimestamp(reinterpret_cast<void *>(ptr)));
}

void FfiConverterSyncedTimestamp::write(RustStream &stream,
                                        const std::shared_ptr<SyncedTimestamp> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterSyncedTimestamp::allocation_size(const std::shared_ptr<SyncedTimestamp> &) {
    return 8;
}

std::shared_ptr<Timestamp> FfiConverterTimestamp::lift(void *ptr) {
    return std::shared_ptr<Timestamp>(new Timestamp(ptr));
}

void *FfiConverterTimestamp::lower(const std::shared_ptr<Timestamp> &obj) {
    return obj->instance;
}

std::shared_ptr<Timestamp> FfiConverterTimestamp::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Timestamp>(new Timestamp(reinterpret_cast<void *>(ptr)));
}

void FfiConverterTimestamp::write(RustStream &stream, const std::shared_ptr<Timestamp> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterTimestamp::allocation_size(const std::shared_ptr<Timestamp> &) {
    return 8;
}

Decay FfiConverterTypeDecay::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeDecay::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeDecay::lower(const Decay &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeDecay::write(stream, val);

    return std::move(buf);
}

Decay FfiConverterTypeDecay::read(RustStream &stream) {
    return {FfiConverterServerTimestamp::read(stream), FfiConverterDuration::read(stream)};
}

void FfiConverterTypeDecay::write(RustStream &stream, const Decay &val) {
    FfiConverterServerTimestamp::write(stream, val.started_at);
    FfiConverterDuration::write(stream, val.length);
}

int32_t FfiConverterTypeDecay::allocation_size(const Decay &val) {

    return FfiConverterServerTimestamp::allocation_size(val.started_at) +
           FfiConverterDuration::allocation_size(val.length);
}

DecayQuery FfiConverterTypeDecayQuery::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeDecayQuery::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeDecayQuery::lower(const DecayQuery &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeDecayQuery::write(stream, val);

    return std::move(buf);
}

DecayQuery FfiConverterTypeDecayQuery::read(RustStream &stream) {
    return {};
}

void FfiConverterTypeDecayQuery::write(RustStream &stream, const DecayQuery &val) {
}

int32_t FfiConverterTypeDecayQuery::allocation_size(const DecayQuery &val) {

    return 0;
}

Identity FfiConverterTypeIdentity::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeIdentity::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeIdentity::lower(const Identity &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeIdentity::write(stream, val);

    return std::move(buf);
}

Identity FfiConverterTypeIdentity::read(RustStream &stream) {
    return {FfiConverterTypeSafeString::read(stream)};
}

void FfiConverterTypeIdentity::write(RustStream &stream, const Identity &val) {
    FfiConverterTypeSafeString::write(stream, val.name);
}

int32_t FfiConverterTypeIdentity::allocation_size(const Identity &val) {

    return FfiConverterTypeSafeString::allocation_size(val.name);
}

Keys FfiConverterTypeKeys::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeKeys::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeKeys::lower(const Keys &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeKeys::write(stream, val);

    return std::move(buf);
}

Keys FfiConverterTypeKeys::read(RustStream &stream) {
    return {FfiConverterPublicKey::read(stream), FfiConverterPrivateKey::read(stream)};
}

void FfiConverterTypeKeys::write(RustStream &stream, const Keys &val) {
    FfiConverterPublicKey::write(stream, val.public_key);
    FfiConverterPrivateKey::write(stream, val.private_key);
}

int32_t FfiConverterTypeKeys::allocation_size(const Keys &val) {

    return FfiConverterPublicKey::allocation_size(val.public_key) +
           FfiConverterPrivateKey::allocation_size(val.private_key);
}

Ping FfiConverterTypePing::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePing::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePing::lower(const Ping &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePing::write(stream, val);

    return std::move(buf);
}

Ping FfiConverterTypePing::read(RustStream &stream) {
    return {};
}

void FfiConverterTypePing::write(RustStream &stream, const Ping &val) {
}

int32_t FfiConverterTypePing::allocation_size(const Ping &val) {

    return 0;
}

ServerError FfiConverterTypeServerError::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeServerError::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeServerError::lower(const ServerError &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeServerError::write(stream, val);

    return std::move(buf);
}

ServerError FfiConverterTypeServerError::read(RustStream &stream) {
    return {FfiConverterTypeErrorCode::read(stream),
            FfiConverterString::read(stream),
            FfiConverterOptionalString::read(stream),
            FfiConverterUInt8::read(stream),
            FfiConverterUInt16::read(stream),
            FfiConverterBool::read(stream)};
}

void FfiConverterTypeServerError::write(RustStream &stream, const ServerError &val) {
    FfiConverterTypeErrorCode::write(stream, val.error_code);
    FfiConverterString::write(stream, val.error_description);
    FfiConverterOptionalString::write(stream, val.error_context);
    FfiConverterUInt8::write(stream, val.request_id);
    FfiConverterUInt16::write(stream, val.message_tag);
    FfiConverterBool::write(stream, val.recoverable);
}

int32_t FfiConverterTypeServerError::allocation_size(const ServerError &val) {

    return FfiConverterTypeErrorCode::allocation_size(val.error_code) +
           FfiConverterString::allocation_size(val.error_description) +
           FfiConverterOptionalString::allocation_size(val.error_context) +
           FfiConverterUInt8::allocation_size(val.request_id) +
           FfiConverterUInt16::allocation_size(val.message_tag) +
           FfiConverterBool::allocation_size(val.recoverable);
}

ServerStatus FfiConverterTypeServerStatus::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeServerStatus::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeServerStatus::lower(const ServerStatus &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeServerStatus::write(stream, val);

    return std::move(buf);
}

ServerStatus FfiConverterTypeServerStatus::read(RustStream &stream) {
    return {FfiConverterServerTimestamp::read(stream), FfiConverterTypeStatus::read(stream)};
}

void FfiConverterTypeServerStatus::write(RustStream &stream, const ServerStatus &val) {
    FfiConverterServerTimestamp::write(stream, val.timestamp);
    FfiConverterTypeStatus::write(stream, val.status);
}

int32_t FfiConverterTypeServerStatus::allocation_size(const ServerStatus &val) {

    return FfiConverterServerTimestamp::allocation_size(val.timestamp) +
           FfiConverterTypeStatus::allocation_size(val.status);
}

std::unique_ptr<EncryptionError> FfiConverterTypeEncryptionError::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeEncryptionError::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterTypeEncryptionError::lower(const EncryptionError &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeEncryptionError::write(stream, val);

    return std::move(buf);
}

std::unique_ptr<EncryptionError> FfiConverterTypeEncryptionError::read(RustStream &stream) {
    int32_t v;
    stream >> v;

    switch (v) {
    case 1: {
        encryption_error::InvalidData var;
        return std::make_unique<encryption_error::InvalidData>(var);
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

void FfiConverterTypeEncryptionError::write(RustStream &stream, const EncryptionError &val) {
    stream << val.get_variant_idx();
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const encryption_error::InvalidData &>(val);
        break;
    }
    }
}

int32_t FfiConverterTypeEncryptionError::allocation_size(const EncryptionError &val) {
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const encryption_error::InvalidData &>(val);
        return static_cast<int32_t>(sizeof(int32_t));
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

ErrorCode FfiConverterTypeErrorCode::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeErrorCode::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeErrorCode::lower(const ErrorCode &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeErrorCode::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeErrorCode::write(stream, val);

    return std::move(buf);
}

ErrorCode FfiConverterTypeErrorCode::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {

    case 1:
        return ErrorCode::kAuthenticationError;

    case 2:
        return ErrorCode::kSerializationError;

    case 3:
        return ErrorCode::kInvalidData;

    case 4:
        return ErrorCode::kIoError;

    case 5:
        return ErrorCode::kServerError;

    default:
        throw std::runtime_error("No matching ErrorCode variant");
    }
}

void FfiConverterTypeErrorCode::write(RustStream &stream, const ErrorCode &val) {
    switch (val) {

    case ErrorCode::kAuthenticationError:
        stream << static_cast<int32_t>(1);
        break;

    case ErrorCode::kSerializationError:
        stream << static_cast<int32_t>(2);
        break;

    case ErrorCode::kInvalidData:
        stream << static_cast<int32_t>(3);
        break;

    case ErrorCode::kIoError:
        stream << static_cast<int32_t>(4);
        break;

    case ErrorCode::kServerError:
        stream << static_cast<int32_t>(5);
        break;

    default:
        throw std::runtime_error("No matching ErrorCode variant");
    }
}

int32_t FfiConverterTypeErrorCode::allocation_size(const ErrorCode &) {
    return static_cast<int32_t>(sizeof(int32_t));
}

SafeString FfiConverterTypeSafeString::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSafeString::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeSafeString::lower(const SafeString &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeSafeString::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSafeString::write(stream, val);

    return std::move(buf);
}

SafeString FfiConverterTypeSafeString::read(RustStream &stream) {
    int32_t variant_id;
    stream >> variant_id;

    switch (variant_id) {

    case 1:
        return SafeString::kEncrypted{
            .data = FfiConverterEncryptedString::read(stream),
        };

    case 2:
        return SafeString::kPlaintext{
            .value = FfiConverterString::read(stream),
        };

    default:
        throw std::runtime_error("No matching SafeString variant");
    }
}

void FfiConverterTypeSafeString::write(RustStream &stream, const SafeString &val) {
    int32_t variant_id = static_cast<int32_t>(val.variant.index() + 1);

    stream << variant_id;

    std::visit(
        [&](auto &&arg) {
            using T = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<T, SafeString::kEncrypted>) {
                FfiConverterEncryptedString::write(stream, arg.data);
            } else if constexpr (std::is_same_v<T, SafeString::kPlaintext>) {
                FfiConverterString::write(stream, arg.value);
            } else {
                static_assert(always_false_v<T>, "non-exhaustive SafeString visitor");
            }
        },
        val.variant);
}

int32_t FfiConverterTypeSafeString::allocation_size(const SafeString &val) {
    int32_t size = sizeof(int32_t);

    size += std::visit(
        [&](auto &&arg) {
            using T = std::decay_t<decltype(arg)>;
            if constexpr (std::is_same_v<T, SafeString::kEncrypted>) {
                int32_t size = 0;
                size += FfiConverterEncryptedString::allocation_size(arg.data);
                return size;
            } else if constexpr (std::is_same_v<T, SafeString::kPlaintext>) {
                int32_t size = 0;
                size += FfiConverterString::allocation_size(arg.value);
                return size;
            } else {
                static_assert(always_false_v<T>, "non-exhaustive SafeString visitor");
            }

            return 0;
        },
        val.variant);

    return size;
}

std::unique_ptr<SerializationError> FfiConverterTypeSerializationError::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSerializationError::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterTypeSerializationError::lower(const SerializationError &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSerializationError::write(stream, val);

    return std::move(buf);
}

std::unique_ptr<SerializationError> FfiConverterTypeSerializationError::read(RustStream &stream) {
    int32_t v;
    stream >> v;

    switch (v) {
    case 1: {
        serialization_error::BadData var;
        var.msg = FfiConverterString::read(stream);
        return std::make_unique<serialization_error::BadData>(var);
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

void FfiConverterTypeSerializationError::write(RustStream &stream, const SerializationError &val) {
    stream << val.get_variant_idx();
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const serialization_error::BadData &>(val);
        FfiConverterString::write(stream, var.msg);
        break;
    }
    }
}

int32_t FfiConverterTypeSerializationError::allocation_size(const SerializationError &val) {
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const serialization_error::BadData &>(val);
        return static_cast<int32_t>(sizeof(int32_t) + FfiConverterString::allocation_size(var.msg));
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

Status FfiConverterTypeStatus::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeStatus::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeStatus::lower(const Status &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeStatus::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeStatus::write(stream, val);

    return std::move(buf);
}

Status FfiConverterTypeStatus::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {

    case 1:
        return Status::kOk;

    default:
        throw std::runtime_error("No matching Status variant");
    }
}

void FfiConverterTypeStatus::write(RustStream &stream, const Status &val) {
    switch (val) {

    case Status::kOk:
        stream << static_cast<int32_t>(1);
        break;

    default:
        throw std::runtime_error("No matching Status variant");
    }
}

int32_t FfiConverterTypeStatus::allocation_size(const Status &) {
    return static_cast<int32_t>(sizeof(int32_t));
}

std::optional<std::string> FfiConverterOptionalString::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterOptionalString::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterOptionalString::lower(const std::optional<std::string> &val) {
    auto buf = rustbuffer_alloc(FfiConverterOptionalString::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterOptionalString::write(stream, val);

    return buf;
}

std::optional<std::string> FfiConverterOptionalString::read(RustStream &stream) {
    char has_value;

    stream.get(has_value);
    if (has_value) {
        return std::make_optional(FfiConverterString::read(stream));
    } else {
        return std::nullopt;
    }
}

void FfiConverterOptionalString::write(RustStream &stream,
                                       const std::optional<std::string> &value) {
    stream.put(static_cast<uint8_t>(!!value));

    if (value) {
        FfiConverterString::write(stream, value.value());
    }
}

int32_t FfiConverterOptionalString::allocation_size(const std::optional<std::string> &val) {
    int32_t ret = 1;

    if (val) {
        ret += FfiConverterString::allocation_size(val.value());
    }

    return ret;
}

} // namespace uniffi

std::string decay_message_tag() {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_decay_message_tag, nullptr);

    return uniffi::FfiConverterString::lift(ret);
}

std::string server_error_message_tag() {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_servererror_message_tag, nullptr);

    return uniffi::FfiConverterString::lift(ret);
}

std::string server_status_message_tag() {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_serverstatus_message_tag, nullptr);

    return uniffi::FfiConverterString::lift(ret);
}

Keys generate_new_keys() {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_generate_new_keys, nullptr);

    return uniffi::FfiConverterTypeKeys::lift(ret);
}
} // namespace logic