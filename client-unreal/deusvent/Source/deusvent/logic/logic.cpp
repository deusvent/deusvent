#pragma clang diagnostic ignored "-Wpessimizing-move"
/* This file was generated by uniffi-bindgen-cpp. */
#include <string>

#include "logic.hpp"

namespace logic {
namespace uniffi {
template <class> inline constexpr bool always_false_v = false;

namespace {
void ensure_initialized() {
    auto bindings_contract_version = 24;
    auto scaffolding_contract_version = ffi_logic_uniffi_contract_version();

    if (bindings_contract_version != scaffolding_contract_version) {
        throw std::runtime_error(
            "UniFFI contract version mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_func_serverstatus_message_tag() != 55415) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_duration_whole_days() != 58703) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_duration_whole_hours() != 60524) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_duration_whole_minutes() != 14664) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_pingserializer_data() != 55445) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_pingserializer_debug_string() != 9881) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_pingserializer_serialize() != 40052) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatusserializer_data() != 48664) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatusserializer_debug_string() != 1117) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_serverstatusserializer_serialize() != 65143) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_servertimestamp_as_string() != 29463) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_syncedtimestamp_adjust() != 41584) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_syncedtimestamp_now() != 943) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_timestamp_as_string() != 3604) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_method_timestamp_diff() != 48627) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_duration_from_milliseconds() != 62484) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_pingserializer_deserialize() != 44314) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_pingserializer_new() != 20928) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_serverstatusserializer_deserialize() != 38819) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_serverstatusserializer_new() != 54043) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_servertimestamp_from_milliseconds() != 5946) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_syncedtimestamp_new() != 19626) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_timestamp_from_milliseconds() != 19208) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
    if (uniffi_logic_checksum_constructor_timestamp_now() != 17293) {
        throw std::runtime_error(
            "UniFFI API checksum mismatch: try cleaning and rebuilding your project");
    }
}

// Note: we need this indirection here and can't inline this code in the rust_call function
// as it's a templated function
void initialize() {
    static std::once_flag init_flag;
    std::call_once(init_flag, ensure_initialized);
}
} // namespace

template <typename F> void check_rust_call(const RustCallStatus &status, F error_cb) {
    switch (status.code) {
    case 0:
        return;

    case 1:
        if constexpr (!std::is_null_pointer_v<F>) {
            error_cb(status.error_buf)->throw_underlying();
        }
        break;

    case 2:
        if (status.error_buf.len > 0) {
            throw std::runtime_error(FfiConverterString::lift(status.error_buf));
        }

        throw std::runtime_error("A Rust panic has occurred");
    }

    throw std::runtime_error("Unexpected Rust call status");
}

template <typename F,
          typename EF,
          typename... Args,
          typename R = std::invoke_result_t<F, Args..., RustCallStatus *>>
R rust_call(F f, EF error_cb, Args... args) {
    initialize();

    RustCallStatus status = {0};

    if constexpr (std::is_void_v<R>) {
        f(args..., &status);
        check_rust_call(status, error_cb);
    } else {
        auto ret = f(args..., &status);
        check_rust_call(status, error_cb);

        return ret;
    }
}

RustBuffer rustbuffer_alloc(int32_t len) {
    RustCallStatus status = {0};
    auto buffer = ffi_logic_rustbuffer_alloc(len, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

RustBuffer rustbuffer_from_bytes(const ForeignBytes &bytes) {
    RustCallStatus status = {0};
    auto buffer = ffi_logic_rustbuffer_from_bytes(bytes, &status);

    check_rust_call(status, nullptr);

    return buffer;
}

void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = {0};

    ffi_logic_rustbuffer_free(std::move(buf), &status);
    check_rust_call(status, nullptr);
}

uint64_t FfiConverterUInt64::lift(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::lower(uint64_t val) {
    return val;
}

uint64_t FfiConverterUInt64::read(RustStream &stream) {
    uint64_t ret;
    stream >> ret;

    return ret;
}

void FfiConverterUInt64::write(RustStream &stream, uint64_t val) {
    stream << val;
}

int32_t FfiConverterUInt64::allocation_size(uint64_t) {
    return static_cast<int32_t>(sizeof(uint64_t));
}

bool FfiConverterBool::lift(uint8_t val) {
    return !!val;
}

uint8_t FfiConverterBool::lower(bool val) {
    return val;
}

bool FfiConverterBool::read(RustStream &stream) {
    uint8_t val;
    stream >> val;

    return val;
}

void FfiConverterBool::write(RustStream &stream, bool val) {
    stream << val;
}

int32_t FfiConverterBool::allocation_size(bool) {
    return 1;
}
std::string FfiConverterString::lift(RustBuffer buf) {
    auto string = std::string(reinterpret_cast<char *>(buf.data), buf.len);

    rustbuffer_free(buf);

    return string;
}

RustBuffer FfiConverterString::lower(const std::string &val) {
    auto len = static_cast<int32_t>(val.length());
    auto bytes = ForeignBytes{len, reinterpret_cast<uint8_t *>(const_cast<char *>(val.data()))};

    return rustbuffer_from_bytes(bytes);
}

std::string FfiConverterString::read(RustStream &stream) {
    int32_t len;
    std::string string;

    stream >> len;

    string.resize(len);
    stream.read(string.data(), len);

    return string;
}

void FfiConverterString::write(RustStream &stream, const std::string &val) {
    stream << static_cast<int32_t>(val.length());
    stream.write(val.data(), val.length());
}

int32_t FfiConverterString::allocation_size(const std::string &val) {
    return static_cast<int32_t>(sizeof(int32_t) + val.length());
}
} // namespace uniffi

Duration::Duration(void *ptr) : instance(ptr) {
}

std::shared_ptr<Duration> Duration::from_milliseconds(uint64_t milliseconds) {
    return std::shared_ptr<Duration>(
        new Duration(uniffi::rust_call(uniffi_logic_fn_constructor_duration_from_milliseconds,
                                       nullptr,
                                       uniffi::FfiConverterUInt64::lower(milliseconds))));
}

uint64_t Duration::whole_days() {
    return uniffi::FfiConverterUInt64::lift(
        uniffi::rust_call(uniffi_logic_fn_method_duration_whole_days, nullptr, this->instance));
}
uint64_t Duration::whole_hours() {
    return uniffi::FfiConverterUInt64::lift(
        uniffi::rust_call(uniffi_logic_fn_method_duration_whole_hours, nullptr, this->instance));
}
uint64_t Duration::whole_minutes() {
    return uniffi::FfiConverterUInt64::lift(
        uniffi::rust_call(uniffi_logic_fn_method_duration_whole_minutes, nullptr, this->instance));
}

Duration::~Duration() {
    uniffi::rust_call(uniffi_logic_fn_free_duration, nullptr, this->instance);
}

PingSerializer::PingSerializer(void *ptr) : instance(ptr) {
}

std::shared_ptr<PingSerializer> PingSerializer::init(const Ping &data) {
    return std::shared_ptr<PingSerializer>(
        new PingSerializer(uniffi::rust_call(uniffi_logic_fn_constructor_pingserializer_new,
                                             nullptr,
                                             uniffi::FfiConverterTypePing::lower(data))));
}

std::shared_ptr<PingSerializer> PingSerializer::deserialize(const std::string &data) {
    return std::shared_ptr<PingSerializer>(
        new PingSerializer(uniffi::rust_call(uniffi_logic_fn_constructor_pingserializer_deserialize,
                                             uniffi::FfiConverterTypeSerializationError::lift,
                                             uniffi::FfiConverterString::lower(data))));
}

Ping PingSerializer::data() {
    return uniffi::FfiConverterTypePing::lift(
        uniffi::rust_call(uniffi_logic_fn_method_pingserializer_data, nullptr, this->instance));
}
std::string PingSerializer::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_pingserializer_debug_string, nullptr, this->instance));
}
std::string PingSerializer::serialize() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_pingserializer_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance));
}

PingSerializer::~PingSerializer() {
    uniffi::rust_call(uniffi_logic_fn_free_pingserializer, nullptr, this->instance);
}

ServerStatusSerializer::ServerStatusSerializer(void *ptr) : instance(ptr) {
}

std::shared_ptr<ServerStatusSerializer> ServerStatusSerializer::init(const ServerStatus &data) {
    return std::shared_ptr<ServerStatusSerializer>(new ServerStatusSerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_serverstatusserializer_new,
                          nullptr,
                          uniffi::FfiConverterTypeServerStatus::lower(data))));
}

std::shared_ptr<ServerStatusSerializer>
ServerStatusSerializer::deserialize(const std::string &input) {
    return std::shared_ptr<ServerStatusSerializer>(new ServerStatusSerializer(
        uniffi::rust_call(uniffi_logic_fn_constructor_serverstatusserializer_deserialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          uniffi::FfiConverterString::lower(input))));
}

ServerStatus ServerStatusSerializer::data() {
    return uniffi::FfiConverterTypeServerStatus::lift(uniffi::rust_call(
        uniffi_logic_fn_method_serverstatusserializer_data, nullptr, this->instance));
}
std::string ServerStatusSerializer::debug_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_serverstatusserializer_debug_string, nullptr, this->instance));
}
std::string ServerStatusSerializer::serialize() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_serverstatusserializer_serialize,
                          uniffi::FfiConverterTypeSerializationError::lift,
                          this->instance));
}

ServerStatusSerializer::~ServerStatusSerializer() {
    uniffi::rust_call(uniffi_logic_fn_free_serverstatusserializer, nullptr, this->instance);
}

ServerTimestamp::ServerTimestamp(void *ptr) : instance(ptr) {
}

std::shared_ptr<ServerTimestamp> ServerTimestamp::from_milliseconds(uint64_t milliseconds) {
    return std::shared_ptr<ServerTimestamp>(new ServerTimestamp(
        uniffi::rust_call(uniffi_logic_fn_constructor_servertimestamp_from_milliseconds,
                          nullptr,
                          uniffi::FfiConverterUInt64::lower(milliseconds))));
}

std::string ServerTimestamp::as_string() {
    return uniffi::FfiConverterString::lift(uniffi::rust_call(
        uniffi_logic_fn_method_servertimestamp_as_string, nullptr, this->instance));
}

ServerTimestamp::~ServerTimestamp() {
    uniffi::rust_call(uniffi_logic_fn_free_servertimestamp, nullptr, this->instance);
}

SyncedTimestamp::SyncedTimestamp(void *ptr) : instance(ptr) {
}

std::shared_ptr<SyncedTimestamp> SyncedTimestamp::init() {
    return std::shared_ptr<SyncedTimestamp>(new SyncedTimestamp(
        uniffi::rust_call(uniffi_logic_fn_constructor_syncedtimestamp_new, nullptr)));
}

void SyncedTimestamp::adjust(const std::shared_ptr<ServerTimestamp> &server_time,
                             const std::shared_ptr<Timestamp> &sent_at,
                             const std::shared_ptr<Timestamp> &received_at) {
    uniffi::rust_call(uniffi_logic_fn_method_syncedtimestamp_adjust,
                      nullptr,
                      this->instance,
                      uniffi::FfiConverterServerTimestamp::lower(server_time),
                      uniffi::FfiConverterTimestamp::lower(sent_at),
                      uniffi::FfiConverterTimestamp::lower(received_at));
}
std::shared_ptr<Timestamp> SyncedTimestamp::now() {
    return uniffi::FfiConverterTimestamp::lift(
        uniffi::rust_call(uniffi_logic_fn_method_syncedtimestamp_now, nullptr, this->instance));
}

SyncedTimestamp::~SyncedTimestamp() {
    uniffi::rust_call(uniffi_logic_fn_free_syncedtimestamp, nullptr, this->instance);
}

Timestamp::Timestamp(void *ptr) : instance(ptr) {
}

std::shared_ptr<Timestamp> Timestamp::from_milliseconds(uint64_t milliseconds) {
    return std::shared_ptr<Timestamp>(
        new Timestamp(uniffi::rust_call(uniffi_logic_fn_constructor_timestamp_from_milliseconds,
                                        nullptr,
                                        uniffi::FfiConverterUInt64::lower(milliseconds))));
}

std::shared_ptr<Timestamp> Timestamp::now() {
    return std::shared_ptr<Timestamp>(
        new Timestamp(uniffi::rust_call(uniffi_logic_fn_constructor_timestamp_now, nullptr)));
}

std::string Timestamp::as_string() {
    return uniffi::FfiConverterString::lift(
        uniffi::rust_call(uniffi_logic_fn_method_timestamp_as_string, nullptr, this->instance));
}
std::shared_ptr<Duration> Timestamp::diff(const std::shared_ptr<Timestamp> &other) {
    return uniffi::FfiConverterDuration::lift(
        uniffi::rust_call(uniffi_logic_fn_method_timestamp_diff,
                          nullptr,
                          this->instance,
                          uniffi::FfiConverterTimestamp::lower(other)));
}

Timestamp::~Timestamp() {
    uniffi::rust_call(uniffi_logic_fn_free_timestamp, nullptr, this->instance);
}

namespace uniffi {

std::shared_ptr<Duration> FfiConverterDuration::lift(void *ptr) {
    return std::shared_ptr<Duration>(new Duration(ptr));
}

void *FfiConverterDuration::lower(const std::shared_ptr<Duration> &obj) {
    return obj->instance;
}

std::shared_ptr<Duration> FfiConverterDuration::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Duration>(new Duration(reinterpret_cast<void *>(ptr)));
}

void FfiConverterDuration::write(RustStream &stream, const std::shared_ptr<Duration> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterDuration::allocation_size(const std::shared_ptr<Duration> &) {
    return 8;
}

std::shared_ptr<PingSerializer> FfiConverterPingSerializer::lift(void *ptr) {
    return std::shared_ptr<PingSerializer>(new PingSerializer(ptr));
}

void *FfiConverterPingSerializer::lower(const std::shared_ptr<PingSerializer> &obj) {
    return obj->instance;
}

std::shared_ptr<PingSerializer> FfiConverterPingSerializer::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<PingSerializer>(new PingSerializer(reinterpret_cast<void *>(ptr)));
}

void FfiConverterPingSerializer::write(RustStream &stream,
                                       const std::shared_ptr<PingSerializer> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterPingSerializer::allocation_size(const std::shared_ptr<PingSerializer> &) {
    return 8;
}

std::shared_ptr<ServerStatusSerializer> FfiConverterServerStatusSerializer::lift(void *ptr) {
    return std::shared_ptr<ServerStatusSerializer>(new ServerStatusSerializer(ptr));
}

void *
FfiConverterServerStatusSerializer::lower(const std::shared_ptr<ServerStatusSerializer> &obj) {
    return obj->instance;
}

std::shared_ptr<ServerStatusSerializer>
FfiConverterServerStatusSerializer::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<ServerStatusSerializer>(
        new ServerStatusSerializer(reinterpret_cast<void *>(ptr)));
}

void FfiConverterServerStatusSerializer::write(RustStream &stream,
                                               const std::shared_ptr<ServerStatusSerializer> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterServerStatusSerializer::allocation_size(
    const std::shared_ptr<ServerStatusSerializer> &) {
    return 8;
}

std::shared_ptr<ServerTimestamp> FfiConverterServerTimestamp::lift(void *ptr) {
    return std::shared_ptr<ServerTimestamp>(new ServerTimestamp(ptr));
}

void *FfiConverterServerTimestamp::lower(const std::shared_ptr<ServerTimestamp> &obj) {
    return obj->instance;
}

std::shared_ptr<ServerTimestamp> FfiConverterServerTimestamp::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<ServerTimestamp>(new ServerTimestamp(reinterpret_cast<void *>(ptr)));
}

void FfiConverterServerTimestamp::write(RustStream &stream,
                                        const std::shared_ptr<ServerTimestamp> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterServerTimestamp::allocation_size(const std::shared_ptr<ServerTimestamp> &) {
    return 8;
}

std::shared_ptr<SyncedTimestamp> FfiConverterSyncedTimestamp::lift(void *ptr) {
    return std::shared_ptr<SyncedTimestamp>(new SyncedTimestamp(ptr));
}

void *FfiConverterSyncedTimestamp::lower(const std::shared_ptr<SyncedTimestamp> &obj) {
    return obj->instance;
}

std::shared_ptr<SyncedTimestamp> FfiConverterSyncedTimestamp::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<SyncedTimestamp>(new SyncedTimestamp(reinterpret_cast<void *>(ptr)));
}

void FfiConverterSyncedTimestamp::write(RustStream &stream,
                                        const std::shared_ptr<SyncedTimestamp> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterSyncedTimestamp::allocation_size(const std::shared_ptr<SyncedTimestamp> &) {
    return 8;
}

std::shared_ptr<Timestamp> FfiConverterTimestamp::lift(void *ptr) {
    return std::shared_ptr<Timestamp>(new Timestamp(ptr));
}

void *FfiConverterTimestamp::lower(const std::shared_ptr<Timestamp> &obj) {
    return obj->instance;
}

std::shared_ptr<Timestamp> FfiConverterTimestamp::read(RustStream &stream) {
    std::uintptr_t ptr;
    stream >> ptr;

    return std::shared_ptr<Timestamp>(new Timestamp(reinterpret_cast<void *>(ptr)));
}

void FfiConverterTimestamp::write(RustStream &stream, const std::shared_ptr<Timestamp> &obj) {
    stream << reinterpret_cast<std::uintptr_t>(obj->instance);
}

int32_t FfiConverterTimestamp::allocation_size(const std::shared_ptr<Timestamp> &) {
    return 8;
}

Ping FfiConverterTypePing::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypePing::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypePing::lower(const Ping &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypePing::write(stream, val);

    return std::move(buf);
}

Ping FfiConverterTypePing::read(RustStream &stream) {
    return {FfiConverterBool::read(stream)};
}

void FfiConverterTypePing::write(RustStream &stream, const Ping &val) {
    FfiConverterBool::write(stream, val.unused);
}

int32_t FfiConverterTypePing::allocation_size(const Ping &val) {
    return FfiConverterBool::allocation_size(val.unused);
}

ServerStatus FfiConverterTypeServerStatus::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeServerStatus::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeServerStatus::lower(const ServerStatus &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeServerStatus::write(stream, val);

    return std::move(buf);
}

ServerStatus FfiConverterTypeServerStatus::read(RustStream &stream) {
    return {FfiConverterServerTimestamp::read(stream), FfiConverterTypeStatus::read(stream)};
}

void FfiConverterTypeServerStatus::write(RustStream &stream, const ServerStatus &val) {
    FfiConverterServerTimestamp::write(stream, val.timestamp);
    FfiConverterTypeStatus::write(stream, val.status);
}

int32_t FfiConverterTypeServerStatus::allocation_size(const ServerStatus &val) {
    return FfiConverterServerTimestamp::allocation_size(val.timestamp) +
           FfiConverterTypeStatus::allocation_size(val.status);
}

std::unique_ptr<SerializationError> FfiConverterTypeSerializationError::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeSerializationError::read(stream);

    rustbuffer_free(buf);

    return ret;
}

RustBuffer FfiConverterTypeSerializationError::lower(const SerializationError &val) {
    auto buf = rustbuffer_alloc(allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeSerializationError::write(stream, val);

    return std::move(buf);
}

std::unique_ptr<SerializationError> FfiConverterTypeSerializationError::read(RustStream &stream) {
    int32_t v;
    stream >> v;

    switch (v) {
    case 1: {
        serialization_error::BadData var;
        var.msg = FfiConverterString::read(stream);
        return std::make_unique<serialization_error::BadData>(var);
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

void FfiConverterTypeSerializationError::write(RustStream &stream, const SerializationError &val) {
    stream << val.get_variant_idx();
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const serialization_error::BadData &>(val);
        FfiConverterString::write(stream, var.msg);
        break;
    }
    }
}

int32_t FfiConverterTypeSerializationError::allocation_size(const SerializationError &val) {
    switch (val.get_variant_idx()) {
    case 1: {
        auto &var = static_cast<const serialization_error::BadData &>(val);
        return static_cast<int32_t>(sizeof(int32_t) + FfiConverterString::allocation_size(var.msg));
    }
    default:
        throw std::runtime_error("Unexpected error variant");
    }
}

Status FfiConverterTypeStatus::lift(RustBuffer buf) {
    auto stream = RustStream(&buf);
    auto ret = FfiConverterTypeStatus::read(stream);

    rustbuffer_free(buf);

    return std::move(ret);
}

RustBuffer FfiConverterTypeStatus::lower(const Status &val) {
    auto buf = rustbuffer_alloc(FfiConverterTypeStatus::allocation_size(val));
    auto stream = RustStream(&buf);

    FfiConverterTypeStatus::write(stream, val);

    return std::move(buf);
}

Status FfiConverterTypeStatus::read(RustStream &stream) {
    int32_t variant;
    stream >> variant;

    switch (variant) {

    case 1:
        return Status::kOk;

    default:
        throw std::runtime_error("No matching Status variant");
    }
}

void FfiConverterTypeStatus::write(RustStream &stream, const Status &val) {
    switch (val) {

    case Status::kOk:
        stream << static_cast<int32_t>(1);
        break;

    default:
        throw std::runtime_error("No matching Status variant");
    }
}

int32_t FfiConverterTypeStatus::allocation_size(const Status &) {
    return static_cast<int32_t>(sizeof(int32_t));
}

} // namespace uniffi

std::string server_status_message_tag() {
    auto ret = uniffi::rust_call(uniffi_logic_fn_func_serverstatus_message_tag, nullptr);

    return uniffi::FfiConverterString::lift(ret);
}
} // namespace logic